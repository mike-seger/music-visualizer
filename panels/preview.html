<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Preset Preview</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: #111; color: #ccc;
  font-family: system-ui, -apple-system, sans-serif;
  font-size: 12px;
  padding: 48px 10px 40px;
}

/* ── Scrollbar ── */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: #0d0d0d; }
::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #444; }
* { scrollbar-color: #333 #0d0d0d; scrollbar-width: thin; }

/* ── Floating toolbar ── */
#toolbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  background: rgba(17,17,17,.92); backdrop-filter: blur(6px);
  border-bottom: 1px solid #2a2a2a;
  display: flex; align-items: center;
  padding: 8px 12px; gap: 10px;
}
#title { color: #888; flex: 1; }
.toolbar-btn {
  background: #222; border: 1px solid #444; color: #ddd;
  padding: 5px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;
  white-space: nowrap;
}
.toolbar-btn:hover { background: #2e2e2e; }
#copy-count { color: #fa4; }
.toolbar-follow { display:flex; align-items:center; gap:5px; color:#aaa; font-size:12px; cursor:pointer; white-space:nowrap; user-select:none; }
.toolbar-follow input { cursor:pointer; accent-color:#44ff9a; width:13px; height:13px; flex-shrink:0; }

/* ── Status bar ── */
#status-bar {
  position: fixed; top: 41px; left: 0; right: 0; z-index: 99;
  background: #1a1a2e; border-bottom: 1px solid #2a2a4a;
  padding: 5px 12px;
  font-size: 11px; color: #89a; letter-spacing: .02em;
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  display: none;
}
#status-bar.visible { display: block; }
body.has-status { padding-top: 68px; }

/* ── Group sections ── */
.group-section { margin-bottom: 20px; }
.group-header {
  display: flex; align-items: center; gap: 8px;
  margin-bottom: 8px;
}
.group-label {
  white-space: nowrap; color: #999;
  font-size: 11px; text-transform: uppercase; letter-spacing: .07em;
}
.group-count { color: #555; font-size: 11px; }
.group-line { flex: 1; height: 1px; background: #2a2a2a; }

/* ── Grid ── */
.grid { display: flex; flex-wrap: wrap; gap: 6px; }

/* ── Tile ── */
.tile {
  position: relative;
  width: var(--tile-w, 240px); height: var(--tile-h, 240px);
  flex-shrink: 0;
  background: #111;
  border-radius: 2px; overflow: hidden;
  outline: 2px solid transparent; outline-offset: 0;
  cursor: pointer;
}
.tile img {
  width: 100%; height: 100%;
  object-fit: contain;
  display: block;
}
.tile:hover { outline-color: #48c; }
.tile.selected { outline-color: #fa4; }
.tile.active { outline-color: #44ff9a; }
.tile.active.selected { outline-color: #fa4; }
.tile.keyboard-focus { outline-color: #0af; }
.tile.keyboard-focus.selected { outline-color: #fa4; }
.tile.keyboard-focus.active { outline-color: #44ff9a; }

/* Checkbox — custom, appears on hover, lives inside the name bar */
.tile-cb {
  flex-shrink: 0;
  width: 15px; height: 15px;
  cursor: pointer;
  pointer-events: auto;
  opacity: 0;
  transition: opacity 0.1s;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  border: 1px solid transparent;
  border-radius: 2px;
}
.tile-cb:checked {
  background: transparent;
  background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12'><polyline points='2,6 5,9 10,3' stroke='%2344ff9a' stroke-width='2.5' fill='none' stroke-linecap='round' stroke-linejoin='round'/></svg>");
  background-repeat: no-repeat;
  background-position: center;
  background-size: 10px 10px;
}
.tile:hover .tile-cb { opacity: 1; border-color: rgba(255,255,255,0.9); }
.tile:hover .tile-cb:checked { border-color: #44ff9a; }
.tile.selected .tile-cb { opacity: 1; }

/* Name bar — flex row: [text ···] [♡] [☐] */
.tile-name {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  padding: 2px 4px;
  background: rgba(0,0,0,.6);
  display: flex;
  align-items: center;
  gap: 4px;
  pointer-events: none;
}
.tile-name-text {
  flex: 1;
  min-width: 0;
  font-size: 11px;
  line-height: 1.4;
  color: #ddd;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  direction: rtl;
  text-align: center;
}
.tile.missing .tile-name { background: rgba(0,0,0,.75); }
.tile.missing .tile-name-text { color: #aaa; }

/* Blue capture button */
.btn-capture {
  background: #1a6fd4; border: 1px solid #4494f0; color: #fff;
  padding: 5px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;
  white-space: nowrap;
  display: none;
}
.btn-capture:hover { background: #2179e8; }
.btn-capture.visible { display: inline-block; }

/* Heart — like button, lives inside the name bar */
.tile-heart {
  flex-shrink: 0;
  width: 15px; height: 15px;
  cursor: pointer;
  pointer-events: auto;
  opacity: 0;
  transition: opacity 0.1s;
  display: flex; align-items: center; justify-content: center;
  background: transparent;
  color: rgba(255,255,255,0.85);
  font-size: 14px;
  line-height: 1;
  user-select: none;
  -webkit-user-select: none;
}
.tile:hover .tile-heart { opacity: 1; }
.tile.liked .tile-heart { opacity: 1; color: #e02020; }

/* ── Overlay (file:// fallback) ── */
#overlay {
  display: none; position: fixed; inset: 0; z-index: 200;
  background: rgba(0,0,0,.88);
  justify-content: center; align-items: center;
  cursor: pointer;
}
#overlay.open { display: flex; }
#overlay-img {
  max-width: 94vw; max-height: 94vh;
  object-fit: contain; border-radius: 3px;
  cursor: default;
}
#overlay-label {
  position: absolute; bottom: 12px; left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,.75); color: #eee;
  padding: 4px 12px; border-radius: 3px;
  font-size: 12px; white-space: nowrap; pointer-events: none;
}
</style>
</head>
<body>

<div id="toolbar">
  <span id="title">Preset Preview</span>
  <button class="btn-capture" id="capture-btn">Capture previews</button>
  <button class="toolbar-btn" id="select-all-btn">Select All</button>
  <button class="toolbar-btn" id="toggle-btn">Toggle</button>
  <button class="toolbar-btn" id="zip-btn">Download ZIP</button>
  <button class="toolbar-btn" id="copy-btn">Copy IDs (<span id="copy-count">all</span>)</button>
  <label class="toolbar-follow" id="follow-label"><input type="checkbox" id="follow-cb"> Follow</label>
</div>

<div id="status-bar"></div>

<div id="root"><p style="color:#555;padding:20px">Waiting for data…</p></div>

<div id="overlay">
  <img id="overlay-img" src="" alt="">
  <div id="overlay-label"></div>
</div>

<script>
(function () {
  var IS_FILE = location.protocol === 'file:'
  var ch
  try { ch = new BroadcastChannel('visualizer-controls') } catch (e) { ch = null }

  // ── Notify main app we are ready (via BroadcastChannel) ──
  if (ch) ch.postMessage({ type: 'preview-ready' })

  var statusBar = document.getElementById('status-bar')
  var captureBtn = document.getElementById('capture-btn')
  var tilesByName = Object.create(null) // presetName → tile element
  var activeName = ''
  var focusIdx = -1          // keyboard-navigation cursor index in filteredItems
  var allItems = []  // full unfiltered list for the current group
  var currentFilter = ''  // tracks the viz-controls name filter
  var filteredItems = []  // current rendered items (after filter)

  var selected = (function () {
    try { return new Set(JSON.parse(localStorage.getItem('visualizer-selected') ?? '[]')) }
    catch { return new Set() }
  })()  // persists across re-renders and page reloads; reset when group changes

  // ── Follow visualizer: auto-select the active tile on visualizer-changed ──
  var followCb = document.getElementById('follow-cb')
  var followVisualizer = (function () {
    try { return localStorage.getItem('visualizer-follow') === '1' } catch { return false }
  })()
  followCb.checked = followVisualizer
  followCb.addEventListener('change', function () {
    followVisualizer = followCb.checked
    try { localStorage.setItem('visualizer-follow', followVisualizer ? '1' : '0') } catch { /* */ }
  })

  var liked = (function () {
    try { return new Set(JSON.parse(localStorage.getItem('visualizer-liked') ?? '[]')) }
    catch { return new Set() }
  })()  // hash-based; never cleared on group change — cross-group favorites

  function saveSelected() {
    try { localStorage.setItem('visualizer-selected', JSON.stringify([...selected])) } catch { /* ignore */ }
  }

  function saveLiked() {
    try { localStorage.setItem('visualizer-liked', JSON.stringify([...liked])) } catch { /* ignore */ }
  }

  function setStatus(text) {
    if (!text) {
      statusBar.classList.remove('visible')
      document.body.classList.remove('has-status')
    } else {
      statusBar.textContent = text
      statusBar.classList.add('visible')
      document.body.classList.add('has-status')
    }
  }

  function setActive(name) {
    if (activeName && tilesByName[activeName]) tilesByName[activeName].classList.remove('active')
    activeName = name || ''
    if (activeName && tilesByName[activeName]) {
      tilesByName[activeName].classList.add('active')
      tilesByName[activeName].scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'smooth' })
    }
  }

  function getTilesPerRow() {
    var grid = document.querySelector('.grid')
    if (!grid || filteredItems.length === 0) return 1
    var tileW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-w')) || 240
    var gap = 6
    return Math.max(1, Math.floor((grid.clientWidth + gap) / (tileW + gap)))
  }

  function setFocusedTile(idx, noScroll) {
    // Remove focus from old tile
    if (focusIdx >= 0 && focusIdx < filteredItems.length) {
      var old = tilesByName[filteredItems[focusIdx].presetName]
      if (old) old.classList.remove('keyboard-focus')
    }
    focusIdx = idx
    if (focusIdx >= 0 && focusIdx < filteredItems.length) {
      var tile = tilesByName[filteredItems[focusIdx].presetName]
      if (tile) {
        tile.classList.add('keyboard-focus')
        if (!noScroll) tile.scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' })
      }
    }
  }

  // ── Capture button ──
  captureBtn.addEventListener('click', function () {
    if (ch) ch.postMessage({ type: 'preview-start' })
  })

  // ── Copy IDs ── (wired once; `selected` and `filteredItems` are module-level)
  var copyCountEl = document.getElementById('copy-count')
  function updateCount() { copyCountEl.textContent = selected.size > 0 ? selected.size : 'all' }
  document.getElementById('copy-btn').addEventListener('click', function () {
    var hashes = selected.size > 0
      ? Array.from(selected).sort()
      : filteredItems.map(function (it) { return it.hash }).sort()
    var text = hashes.join('\n')
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).catch(function () { fallbackCopy(text) })
    } else {
      fallbackCopy(text)
    }
  })

  // ── Select All ──
  document.getElementById('select-all-btn').addEventListener('click', function () {
    filteredItems.forEach(function (it) { selected.add(it.hash) })
    Object.keys(tilesByName).forEach(function (name) {
      var tile = tilesByName[name]
      if (!tile) return
      tile.classList.add('selected')
      var cb = tile.querySelector('.tile-cb'); if (cb) cb.checked = true
    })
    saveSelected(); updateCount()
  })

  // ── Toggle selection ──
  document.getElementById('toggle-btn').addEventListener('click', function () {
    filteredItems.forEach(function (it) {
      var tile = tilesByName[it.presetName]
      var cb = tile && tile.querySelector('.tile-cb')
      if (selected.has(it.hash)) {
        selected.delete(it.hash)
        if (tile) tile.classList.remove('selected')
        if (cb) cb.checked = false
      } else {
        selected.add(it.hash)
        if (tile) tile.classList.add('selected')
        if (cb) cb.checked = true
      }
    })
    saveSelected(); updateCount()
  })

  // ── Receive messages via BroadcastChannel ──
  if (ch) ch.addEventListener('message', function (e) {
    if (!e.data) return
    if (e.data.type === 'preview-status') {
      setStatus(e.data.text || '')
      return
    }
    if (e.data.type === 'preview-data') {
      setStatus('')
      // Reset selection only when a new group's data arrives (not after regen)
      if (!e.data.keepSelection) {
        selected.clear()
        saveSelected()
        updateCount()
      }
      allItems = e.data.items || []
      var mc = e.data.missingCount != null ? e.data.missingCount : 0
      if (mc > 0) {
        captureBtn.textContent = 'Capture ' + mc + ' preview' + (mc === 1 ? '' : 's')
        captureBtn.classList.add('visible')
      } else {
        captureBtn.classList.remove('visible')
      }
      applyFilter(e.data.activePreset || '')
      return
    }
    if (e.data.type === 'preview-tile-update') {
      var upd = e.data.item
      if (!upd) return
      // Mutate the existing item object so all makeTile closures see the new values
      for (var ai = 0; ai < allItems.length; ai++) {
        if (allItems[ai].presetName === upd.presetName) {
          allItems[ai].hash    = upd.hash
          allItems[ai].blobUrl = upd.blobUrl
          allItems[ai].missing = false
          break
        }
      }
      // Patch the DOM tile in place — no full re-render needed
      var updTile = tilesByName[upd.presetName]
      if (updTile) {
        updTile.classList.remove('missing')
        var updImg = updTile.querySelector('img')
        if (updImg) updImg.src = upd.blobUrl
      }
      return
    }
    if (e.data.type === 'preview-regen-request') {
      var regenNames = []
      for (var ai = 0; ai < allItems.length; ai++) {
        if (selected.has(allItems[ai].hash)) regenNames.push(allItems[ai].presetName)
      }
      if (ch) ch.postMessage({ type: 'preview-regen', names: regenNames })
      return
    }
    if (e.data.type === 'preview-filter') {
      currentFilter = e.data.filter || ''
      applyFilter()
      return
    }
    if (e.data.type === 'visualizer-changed' && e.data.name) {
      setActive(e.data.name)
      // Keep keyboard cursor in sync with what's playing
      var changeIdx = -1
      for (var ci = 0; ci < filteredItems.length; ci++) {
        if (filteredItems[ci].presetName === e.data.name) { changeIdx = ci; break }
      }
      setFocusedTile(changeIdx, /*noScroll=*/true) // setActive already scrolled
      // Auto-select the active tile when Follow is enabled
      if (followVisualizer && changeIdx >= 0) {
        var followItem = filteredItems[changeIdx]
        if (followItem && !selected.has(followItem.hash)) {
          selected.add(followItem.hash)
          var followTile = tilesByName[followItem.presetName]
          if (followTile) {
            followTile.classList.add('selected')
            var followCbEl = followTile.querySelector('.tile-cb')
            if (followCbEl) followCbEl.checked = true
          }
          saveSelected()
          updateCount()
        }
      }
    }
  })

  // ── ZIP button ──
  document.getElementById('zip-btn').addEventListener('click', function () {
    var hashes = selected.size > 0 ? Array.from(selected) : null
    if (ch) ch.postMessage({ type: 'preview-zip', hashes: hashes })
  })

  // ── Filter + render ──
  function applyFilter(activePreset) {
    var raw = currentFilter
    var items
    if (!raw.trim()) {
      items = allItems
    } else {
      try {
        var re = new RegExp(raw, 'i')
        items = allItems.filter(function (it) { return re.test(it.presetName) })
      } catch (e) {
        items = allItems  // invalid regex — show all
      }
    }
    render(items, activePreset != null ? activePreset : activeName, allItems.length)
  }

  function render(items, activePreset, totalCount) {
    tilesByName = Object.create(null)
    activeName = ''
    // Detect aspect ratio from the first image and size all tiles to fit
    if (items.length > 0) {
      var probe = new Image()
      probe.onload = function () {
        var scale = Math.min(240 / probe.naturalWidth, 240 / probe.naturalHeight)
        var tw = Math.round(probe.naturalWidth  * scale)
        var th = Math.round(probe.naturalHeight * scale)
        document.documentElement.style.setProperty('--tile-w', tw + 'px')
        document.documentElement.style.setProperty('--tile-h', th + 'px')
      }
      probe.src = items[0].blobUrl
    }

    var root = document.getElementById('root')
    var titleEl = document.getElementById('title')
    root.innerHTML = ''
    var total = (totalCount != null) ? totalCount : items.length
    if (total !== items.length) {
      titleEl.textContent = 'Matching ' + items.length + ' of ' + total + ' presets'
    } else {
      titleEl.textContent = items.length + ' Presets'
    }

    filteredItems = items
    // All items are for the same group — render flat grid, no group header needed
    var grid = document.createElement('div')
    grid.className = 'grid'
    for (var i = 0; i < items.length; i++) {
      grid.appendChild(makeTile(items[i]))
    }
    root.appendChild(grid)

    // Mark the active preset after all tiles are in the DOM
    if (activePreset) setActive(activePreset)

    // Initialise keyboard cursor to the active preset (or clear it)
    var kbIdx = -1
    for (var ki = 0; ki < items.length; ki++) {
      if (items[ki].presetName === (activePreset || activeName)) { kbIdx = ki; break }
    }
    setFocusedTile(kbIdx, /*noScroll=*/true)  // don't double-scroll; setActive already did
  }

  function makeTile(item) {
    var overlay = document.getElementById('overlay')
    var overlayImg = document.getElementById('overlay-img')
    var overlayLbl = document.getElementById('overlay-label')

    var tile = document.createElement('div')
    tile.className = 'tile' + (item.missing ? ' missing' : '')
    tile.title = item.presetName
    tilesByName[item.presetName] = tile

    var img = document.createElement('img')
    img.src = item.blobUrl
    img.alt = item.presetName
    img.loading = 'lazy'
    img.draggable = false

    // Name bar: [text ···] [♡] [☐]
    var nameDiv = document.createElement('div')
    nameDiv.className = 'tile-name'
    var nameText = document.createElement('span')
    nameText.className = 'tile-name-text'
    nameText.textContent = item.presetName

    var heart = document.createElement('span')
    heart.className = 'tile-heart'
    heart.textContent = '\u2661'  // ♡ outline
    heart.title = 'Like'
    heart.addEventListener('click', function (e) {
      e.stopPropagation()
      if (liked.has(item.hash)) {
        liked.delete(item.hash)
        tile.classList.remove('liked')
        heart.textContent = '\u2661'  // ♡
      } else {
        liked.add(item.hash)
        tile.classList.add('liked')
        heart.textContent = '\u2665'  // ♥ filled
      }
      saveLiked()
    })

    var cb = document.createElement('input')
    cb.type = 'checkbox'
    cb.className = 'tile-cb'

    cb.addEventListener('change', function (e) {
      e.stopPropagation()
      if (cb.checked) { selected.add(item.hash); tile.classList.add('selected') }
      else            { selected.delete(item.hash); tile.classList.remove('selected') }
      saveSelected()
      updateCount()
    })
    cb.addEventListener('click', function (e) { e.stopPropagation() })

    tile.addEventListener('click', function () {
      if (IS_FILE) {
        // File-system fallback: lightbox
        overlayImg.src = item.blobUrl
        overlayLbl.textContent = item.presetName
        overlay.classList.add('open')
      } else {
        // Live server: switch preset in main app via BroadcastChannel
        if (ch) ch.postMessage({ type: 'select-visualizer', name: item.presetName })
      }
    })

    // Assemble name bar: text + heart + checkbox
    nameDiv.appendChild(nameText)
    nameDiv.appendChild(heart)
    nameDiv.appendChild(cb)

    tile.appendChild(img)
    tile.appendChild(nameDiv)
    if (liked.has(item.hash)) {
      tile.classList.add('liked')
      heart.textContent = '\u2665'  // ♥ filled
    }

    // Restore persisted selected state (hash-based, group-scoped)
    if (selected.has(item.hash)) {
      cb.checked = true
      tile.classList.add('selected')
    }

    return tile
  }

  // ── Overlay (file:// only) ──
  var overlay = document.getElementById('overlay')
  overlay.addEventListener('click', function (e) {
    if (e.target !== document.getElementById('overlay-img')) overlay.classList.remove('open')
  })
  // ── Keyboard navigation ──
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') { overlay.classList.remove('open'); return }

    // Arrow-key navigation only when the overlay is closed and there are tiles
    if (overlay.classList.contains('open')) return
    if (!filteredItems.length) return

    var n = filteredItems.length
    var handled = true
    var wasArrow = false

    if (e.key === 'ArrowRight') {
      setFocusedTile(focusIdx < 0 ? 0 : (focusIdx + 1) % n); wasArrow = true
    } else if (e.key === 'ArrowLeft') {
      setFocusedTile(focusIdx < 0 ? n - 1 : (focusIdx - 1 + n) % n); wasArrow = true
    } else if (e.key === 'ArrowDown') {
      if (focusIdx < 0) {
        setFocusedTile(0)
      } else {
        var perRow = getTilesPerRow()
        var next = focusIdx + perRow
        setFocusedTile(next < n ? next : focusIdx) // clamp at last row
      }
      wasArrow = true
    } else if (e.key === 'ArrowUp') {
      if (focusIdx < 0) {
        setFocusedTile(0)
      } else {
        var perRow = getTilesPerRow()
        var prev = focusIdx - perRow
        setFocusedTile(prev >= 0 ? prev : focusIdx) // clamp at first row
      }
      wasArrow = true
    } else if ((e.key === 'Enter' || e.key === ' ') && focusIdx >= 0) {
      var item = filteredItems[focusIdx]
      if (IS_FILE) {
        document.getElementById('overlay-img').src = item.blobUrl
        document.getElementById('overlay-label').textContent = item.presetName
        overlay.classList.add('open')
      } else {
        if (ch) ch.postMessage({ type: 'select-visualizer', name: item.presetName })
      }
    } else {
      handled = false
    }

    // Immediately switch preset on arrow navigation (no Enter required)
    if (wasArrow && !IS_FILE && ch && focusIdx >= 0) {
      ch.postMessage({ type: 'select-visualizer', name: filteredItems[focusIdx].presetName })
    }

    if (handled) e.preventDefault()
  })

  function fallbackCopy(text) {
    var ta = document.createElement('textarea')
    ta.value = text
    ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px'
    document.body.appendChild(ta); ta.select()
    try { document.execCommand('copy') } catch (e) {}
    document.body.removeChild(ta)
  }

  function esc(s) {
    return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
  }
})()
</script>
</body>
</html>
