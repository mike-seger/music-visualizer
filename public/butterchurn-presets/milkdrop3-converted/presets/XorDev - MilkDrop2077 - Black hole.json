{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":7,"additivewave":1,"wave_thick":1,"wave_brighten":0,"brighten":1,"darken":1,"wave_a":3.2,"wave_scale":1.768,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpscale":1.331,"fshader":1,"zoom":0.99951,"warp":0.01,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":1.248,"mv_l":5,"mv_b":0,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    // sample previous frame\n    ret =texture( sampler_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret *= 0.94; //or try: ret -= 0.004;\n}","comp":"float _pow(float b,float e){return pow(b,e);}\nvec2  _pow(vec2  b,float e){return pow(b,vec2(e));}\nvec3  _pow(vec3  b,float e){return pow(b,vec3(e));}\nvec4  _pow(vec4  b,float e){return pow(b,vec4(e));}\nshader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n   \n    // Calculate aspect ratio correction\n    float aspect = aspect.x / aspect.y;\n    vec2 aspect_scale = vec2(aspect, 1.0);\n    \n    // Center and scale UVs\n    vec2 uv_centered = (uv - 0.5) * 1.8;\n    vec2 p = uv_centered * aspect_scale;\n\n    vec2 d = vec2(-1, 1);\n    vec2 c = (mat2(1, 1, d / (0.5 + 5.0 / dot(5.0 * p - d, 5.0 * p - d))) * p);\n    vec2 v = c;\n    v = (mat2(cos(log(length(v)) + time * 0.5 + vec4(0, 33, 11, 0))) * v) * 5.0;\n\n    vec4 o = vec4(0);\n    for(float i = 0; i < 9; i++) {\n        o += sin(vec4(v.x, v.y, v.y, v.x)) + 1.0;\n        v += 0.9 * sin(vec2(v.y, v.x) * i + time) / i + 0.5;\n    }\n\n    ret =1.0 - exp(-exp(c.x * vec4(0.6, -0.4+bass_att,1.4, 0)) \n    / o / (0.1 + 0.1 * _pow(length(sin(v / 0.3) * 0.2 + c * vec2(1, 2)) - 1.0, 2.0)) \n    / (1.0 + bass_att*5.0 * exp(0.3 * c.y - dot(c, c))) / (0.03 + abs(length(p) - 0.7)) * 0.2);\n}","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret *= 0.94; //or try: ret -= 0.004;\n}","comp_hlsl":"shader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n   \n    // Calculate aspect ratio correction\n    float aspect = aspect.x / aspect.y;\n    float2 aspect_scale = float2(aspect, 1.0);\n    \n    // Center and scale UVs\n    float2 uv_centered = (uv - 0.5) * 1.8;\n    float2 p = uv_centered * aspect_scale;\n\n    float2 d = float2(-1, 1);\n    float2 c = mul(p, float2x2(1, 1, d / (0.5 + 5.0 / dot(5.0 * p - d, 5.0 * p - d))));\n    float2 v = c;\n    v = mul(v, float2x2(cos(log(length(v)) + time * 0.5 + float4(0, 33, 11, 0)))) * 5.0;\n\n    float4 o = 0;\n    for(float i = 0; i < 9; i++) {\n        o += sin(float4(v.x, v.y, v.y, v.x)) + 1.0;\n        v += 0.9 * sin(float2(v.y, v.x) * i + time) / i + 0.5;\n    }\n\n    ret = 1.0 - exp(-exp(c.x * float4(0.6, -0.4+bass_att,1.4, 0)) \n    / o / (0.1 + 0.1 * pow(length(sin(v / 0.3) * 0.2 + c * float2(1, 2)) - 1.0, 2.0)) \n    / (1.0 + bass_att*5.0 * exp(0.3 * c.y - dot(c, c))) / (0.03 + abs(length(p) - 0.7)) * 0.2);\n}"}