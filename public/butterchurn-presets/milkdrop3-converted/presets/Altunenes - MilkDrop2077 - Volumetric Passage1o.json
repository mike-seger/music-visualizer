{"version":2,"baseVals":{"rating":5,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":15,"additivewave":1,"wave_thick":1,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":0.625,"wave_smoothing":0.9,"modwavealphastart":0.88,"modwavealphaend":1.98,"warpscale":1.331,"fshader":1,"zoom":0.9995,"warp":0.009,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":1,"mv_r":1.06,"mv_b":0.819,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['d'] = 0; a['n'] = 0; a['z'] = 0; a['n2'] = 0; a['q25'] = 0; a['w2'] = 0; a['q22'] = 0; a['q21'] = 0; a['q29'] = 0; a['j3'] = 0; a['q1'] = 0; a['n1'] = 0; a['v'] = 0; a['w3'] = 0; a['q31'] = 0; a['q23'] = 0; a['q24'] = 0; a['pi'] = 0; a['pi2inv'] = 0; a['j2'] = 0; a['w1'] = 0; a['zz'] = 0; a['vol'] = 0; a['j1'] = 0; a['q27'] = 0; a['maskangle'] = 0; a['q3'] = 0; a['q32'] = 0; a['q28'] = 0; a['q30'] = 0; a['q20'] = 0; a['mtime'] = 0; a['x1']=2; a['y1']=2; a['z1']=2;}());","frame_eqs_str":"(function(){a['d']=20; a['z']=4; a['zz']=(1+(a['bass_att']*0)); a['pi']=(Math.asin(1)*2); a['pi2inv']=div(0.5,a['pi']); a['maskangle']=Math.asin(div(1,a['d'])); a['q32']=a['maskangle']; a['q31']=a['d']; a['q30']=a['z']; a['q29']=a['pi2inv']; a['q28']=a['pi']; a['q27']=div(1,a['zz']); a['v']=0.4; a['j1']=((a['j1']*0.95)+(sqr((a['bass']*4))*a['v'])); a['j2']=((a['j2']*0.95)+(sqr((a['mid']*4))*a['v'])); a['j3']=((a['j3']*0.95)+(sqr((a['treb']*4))*a['v'])); a['n']=(a['n']+(a['j1']*0.0152)); a['n1']=(a['n1']+(a['j2']*0.0152)); a['n2']=(a['n2']+(a['j3']*0.0152)); a['vol']=(((a['bass']+a['mid'])+a['treb'])*0.25); a['vol']=a['vol']; a['q3']=a['vol']; a['mtime']=(a['mtime']+(a['vol']*0.01)); a['q1']=a['mtime']; a['zoom']=(a['zoom']+(0.015*a['vol'])); a['w1']=(a['n']*0.01); a['w2']=(a['n1']*0.01); a['w3']=(a['n2']*0.01); a['q20']=Math.cos(a['w1']); a['q21']=Math.sin(a['w1']); a['q22']=Math.cos(a['w2']); a['q23']=Math.sin(a['w2']); a['q24']=Math.cos(a['w3']); a['q25']=Math.sin(a['w3']);}());","pixel_eqs_str":"","init_eqs_eel":"x1 = 2;\ny1= 2;\nz1 = 2;","frame_eqs_eel":"// raytraced sphere code\n\nd = 20; // distance of the sphere, the farther you're away the more you'll see on the horizon\nz = 4; // distance of the pane where the scene is projected on, wider distance = smaller apex angle of the camera, very small distances = fish eyes view\n\nzz = 1 + bass_att*0; // linear zoom\n\npi = asin(1)*2;\npi2inv = 0.5/pi;\nmaskangle = asin( 1/d);\nq32 = maskangle; // hit = (cameras angle < mask_angle)\nq31 = d;\nq30 = z;\nq29 = pi2inv;\nq28 = pi;\nq27 = 1/zz;\n\nv = 0.4;\nj1 = j1*0.95 + sqr(bass*4)*v;\nj2 = j2*0.95 + sqr(mid*4)*v;\nj3 = j3*0.95 + sqr(treb*4)*v;\n\nn = n + j1*0.0152;\nn1 = n1 + j2*0.0152;\nn2 = n2 + j3*0.0152;\n\nvol=(bass+mid+treb)*0.25;\nvol=vol;\nq3=vol;\nmtime = mtime+vol*0.01;\nq1=mtime;\n\nzoom = zoom + 0.015*vol;\n\nw1 = n*0.01;    // solid angles to rotate the sphere in its origin\nw2 = n1*0.01;\nw3 = n2*0.01;\n\nq20 = cos(w1);\nq21 = sin(w1);\nq22 = cos(w2);\nq23 = sin(w2);\nq24 = cos(w3);\nq25 = sin(w3);","pixel_eqs_eel":"","warp":"//Shader by Altunenes\n//https://www.shadertoy.com/view/w33GRl\n//Ported to MilkDrop by MilkDrop2077\n\n// Noise function\nfloat n(vec2 p) {\n   return sin(p.x*3.0+sin(p.y*2.7))*cos(p.y*1.1+cos(p.x*2.3));\n}\n\n// Fractal function\nfloat f(vec3 p) {\n    float v = 0.0, a = 1.0;\n    for(int i=0; i<7; i++) {\n       v += n(p.xy+p.z*0.5)*a;\n       p *= 2.0;\n       a *= 0.5;\n    }\n    return v;\n}\n\nshader_body {\n    // Initialize output\n    ret =vec4(0, 0, 0, 1).xyz;\n    \n    // Coordinate setup with aspect ratio correction\n    float aspect = aspect.x/aspect.y;\n    uv = (uv.xy-0.5)*vec2(aspect,1.0);\n    vec3 o = vec3(0,0,0);\n    float z = 0.0, d = 0.0, t = time;\n    float N = 0.0;\n    \n    // Raymarching loop\n    for(int i=0; i<50; i++) {\n        // Ray setup\n        vec3 p = z*normalize(vec3(uv.x, uv.y, 1.0));\n        p.z += t;\n        \n        // Rotation matrix inspired by mrange's work\n        float angle = p.z;\n        mat2 R = mat2(cos(angle), -sin(angle), \n                             sin(angle), cos(angle));\n        p.xy = (R * p.xy);\n        \n        // Fractal evaluation\n        N = f(p+q1/2 + t*0.1);\n        d = length(p.xy)-1.0+N*0.3;\n        p.z = fmod(p.z,4.0+cos(q6))-3.0;\n        d = abs(d)+0.01;\n        \n        // Color composition\n        vec3 c = vec3(0.1,0.3,0.8)/(length(p.xy+N+bass_att)*0.8);\n        c += vec3(0.8,0.4,0.2)/(length(p.xz+N)*0.5);\n        c += vec3(1.0,1.0,2.0)*(0.5+0.5*sin(N*1.0+t));\n        \n        // Accumulate color with falloff\n        o += c/d*0.12;\n        z += d*0.6;\n    }\n    \n    // Final color processing\n    ret.rgb = tanh(o*0.001);\n}","comp":"shader_body\n{\n    ret =texture(sampler_main, uv).xyz;\nret*=2;\n//ret-=0.2;\n}","warp_hlsl":"//Shader by Altunenes\n//https://www.shadertoy.com/view/w33GRl\n//Ported to MilkDrop by MilkDrop2077\n\n// Noise function\nfloat n(float2 p) {\n   return sin(p.x*3.0+sin(p.y*2.7))*cos(p.y*1.1+cos(p.x*2.3));\n}\n\n// Fractal function\nfloat f(float3 p) {\n    float v = 0.0, a = 1.0;\n    for(int i=0; i<7; i++) {\n       v += n(p.xy+p.z*0.5)*a;\n       p *= 2.0;\n       a *= 0.5;\n    }\n    return v;\n}\n\nshader_body {\n    // Initialize output\n    ret = float4(0, 0, 0, 1);\n    \n    // Coordinate setup with aspect ratio correction\n    float aspect = aspect.x/aspect.y;\n    uv = (uv.xy-0.5)*float2(aspect,1.0);\n    float3 o = float3(0,0,0);\n    float z = 0.0, d = 0.0, t = time;\n    float N = 0.0;\n    \n    // Raymarching loop\n    for(int i=0; i<50; i++) {\n        // Ray setup\n        float3 p = z*normalize(float3(uv.x, uv.y, 1.0));\n        p.z += t;\n        \n        // Rotation matrix inspired by mrange's work\n        float angle = p.z;\n        float2x2 R = float2x2(cos(angle), -sin(angle), \n                             sin(angle), cos(angle));\n        p.xy = mul(p.xy, R);\n        \n        // Fractal evaluation\n        N = f(p+q1/2 + t*0.1);\n        d = length(p.xy)-1.0+N*0.3;\n        p.z = fmod(p.z,4.0+cos(q6))-3.0;\n        d = abs(d)+0.01;\n        \n        // Color composition\n        float3 c = float3(0.1,0.3,0.8)/(length(p.xy+N+bass_att)*0.8);\n        c += float3(0.8,0.4,0.2)/(length(p.xz+N)*0.5);\n        c += float3(1.0,1.0,2.0)*(0.5+0.5*sin(N*1.0+t));\n        \n        // Accumulate color with falloff\n        o += c/d*0.12;\n        z += d*0.6;\n    }\n    \n    // Final color processing\n    ret.rgb = tanh(o*0.001);\n}","comp_hlsl":"shader_body\n{\n    ret = tex2D(sampler_main, uv).xyz;\nret*=2;\n//ret-=0.2;\n}"}