{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":1,"wave_thick":1,"wave_brighten":0,"brighten":1,"darken":1,"wave_a":0.004,"wave_scale":0.037,"wave_smoothing":0,"wave_mystery":-0.44,"modwavealphastart":1,"modwavealphaend":1,"warpscale":1.331,"fshader":1,"zoom":0.9995,"warp":0.009,"wave_y":0.04,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"sides":30,"textured":1,"rad":2.4531,"ang":3.20442,"tex_zoom":0.74187,"r":0,"g":1,"b":1,"a":0.62,"r2":1,"b2":1,"border_a":0},"init_eqs_str":" ","frame_eqs_str":"(function(){a['tex_ang']=(0.03*a['time']);}());","init_eqs_eel":"","frame_eqs_eel":"tex_ang=.03*time;"},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.05;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const vec2 p = uv * PI2 - 250.0;\n    vec2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const vec2 i_plus_t = i + t;\n        const vec2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x)+time;\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const vec2 pd = vec2(p.x/denom, p.y/denom2);\n        c += inversesqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - pow(c, 1.4);\n    const vec3 colour = pow(abs(c), 8.0);\n    ret = vec4(colour, 1.0);\n}","comp":"shader_body\n{\n  //MilkDrop2077 shader using claude AI\n\n  // Heart shape using standard mathematical formula\n  vec2 uv2 = uv - 0.5;\n  uv2.x *= texsize.x/texsize.y;  // correct aspect ratio\n  \n  // Scale and flip the coordinates\n  uv2.y = -uv2.y;\n  uv2 *= 2.5;\n  \n  // Standard heart formula\n  vec2 q = vec2(uv2.x, uv2.y - sqrt(abs(uv2.x))*0.5);\n  float d = length(q) - 0.5 + 0.15*sin(time);\n  \n  // Create a soft glow effect\n  float glow = 0.05/abs(d);\n  glow = clamp(glow, 0.0, 1.0);\n  \n  // Basic colors from the texture\n  vec3 base = texture(sampler_main, uv).xyz;\n  \n  // Add the heart with color\n  vec3 heartColor = vec3(0.8, 0.1, 0.3);  // red heart\n  heartColor *= 1.0 + 0.2*sin(time);  // pulsing effect\n  \n  // Combine everything\n  ret = base*1.3 + glow*1.5 * heartColor*bass_att;\n  \n  // Add some radial glow from the center\n // float center_glow = 0.02/length(uv2);\n // ret += center_glow * vec3(1,0.7,0.8) * 0.5;\n  \n  // Ensure we don't exceed valid color ranges\n  ret = clamp(ret, 0.0, 1.0);\n\n//MilkDrop3 Burn Mode:\n//ret = mix(ret,1,texture(sampler_main, uv).xyz.z*1.25);\nret-=0.05;\n}","warp_hlsl":"shader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.05;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const float2 p = uv * PI2 - 250.0;\n    float2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const float2 i_plus_t = i + t;\n        const float2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x)+time;\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const float2 pd = float2(p.x/denom, p.y/denom2);\n        c += rsqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - pow(c, 1.4);\n    const float3 colour = pow(abs(c), 8.0);\n    ret = float4(colour, 1.0);\n}","comp_hlsl":"shader_body\n{\n  //MilkDrop2077 shader using claude AI\n\n  // Heart shape using standard mathematical formula\n  float2 uv2 = uv - 0.5;\n  uv2.x *= texsize.x/texsize.y;  // correct aspect ratio\n  \n  // Scale and flip the coordinates\n  uv2.y = -uv2.y;\n  uv2 *= 2.5;\n  \n  // Standard heart formula\n  float2 q = float2(uv2.x, uv2.y - sqrt(abs(uv2.x))*0.5);\n  float d = length(q) - 0.5 + 0.15*sin(time);\n  \n  // Create a soft glow effect\n  float glow = 0.05/abs(d);\n  glow = saturate(glow);\n  \n  // Basic colors from the texture\n  float3 base = tex2D(sampler_main, uv).xyz;\n  \n  // Add the heart with color\n  float3 heartColor = float3(0.8, 0.1, 0.3);  // red heart\n  heartColor *= 1.0 + 0.2*sin(time);  // pulsing effect\n  \n  // Combine everything\n  ret = base*1.3 + glow*1.5 * heartColor*bass_att;\n  \n  // Add some radial glow from the center\n // float center_glow = 0.02/length(uv2);\n // ret += center_glow * float3(1,0.7,0.8) * 0.5;\n  \n  // Ensure we don't exceed valid color ranges\n  ret = saturate(ret);\n\n//MilkDrop3 Burn Mode:\n//ret = lerp(ret,1,GetPixel(uv).z*1.25);\nret-=0.05;\n}"}