{"version":2,"baseVals":{"rating":1,"gammaadj":1.8,"echo_zoom":1.905,"echo_orient":2,"wave_mode":6,"additivewave":1,"wave_dots":1,"modwavealphabyvolume":1,"wave_a":0.9,"wave_scale":1.988,"wave_smoothing":0.639,"modwavealphastart":0.33,"warpscale":2.853,"zoomexp":1.00563,"zoom":1.02068,"warp":0.28082,"wave_r":0.6,"wave_g":0.6,"wave_b":0.6,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['n'] = 0; a['tic'] = 0; a['lookatx'] = 0; a['rg2'] = 0; a['rg4'] = 0; a['shadowstrength'] = 0; a['q25'] = 0; a['vav2'] = 0; a['q12'] = 0; a['up'] = 0; a['q18'] = 0; a['q22'] = 0; a['q21'] = 0; a['vt'] = 0; a['q13'] = 0; a['q15'] = 0; a['q29'] = 0; a['q6'] = 0; a['sunx'] = 0; a['cameraposmul'] = 0; a['q1'] = 0; a['q5'] = 0; a['q9'] = 0; a['shakex'] = 0; a['rg_treb'] = 0; a['cameraposy'] = 0; a['tin'] = 0; a['count'] = 0; a['rg22'] = 0; a['suny'] = 0; a['q31'] = 0; a['q23'] = 0; a['q24'] = 0; a['rg_mid'] = 0; a['rg3'] = 0; a['q11'] = 0; a['pi'] = 0; a['q10'] = 0; a['vav'] = 0; a['rg_mid2'] = 0; a['cameraposz'] = 0; a['beat2'] = 0; a['rg1'] = 0; a['stars1speed'] = 0; a['rg12'] = 0; a['q16'] = 0; a['lookaty'] = 0; a['q26'] = 0; a['lightzpos'] = 0; a['torusrotspeed'] = 0; a['ra'] = 0; a['stars2speed'] = 0; a['shakey'] = 0; a['q19'] = 0; a['beat'] = 0; a['q17'] = 0; a['rg13'] = 0; a['cameraxzspeed'] = 0; a['rg23'] = 0; a['q2'] = 0; a['q27'] = 0; a['rg32'] = 0; a['torusrot'] = 0; a['q14'] = 0; a['rg_treb2'] = 0; a['cameraposx'] = 0; a['rg33'] = 0; a['rg_bass'] = 0; a['q3'] = 0; a['lightingpower'] = 0; a['q32'] = 0; a['cameraoutsideoftorus'] = 0; a['q7'] = 0; a['q28'] = 0; a['lookatz'] = 0; a['q30'] = 0; a['q20'] = 0; a['q8'] = 0; a['check1']=1; a['check2']=0; a['check3']=0; a['count']=1;}());","frame_eqs_str":"(function(){a['pi']=3.141592654; a['wave_a']=0; a['warp']=0; a['rg1']=Math.max((a['rg1']*0.87), (0.00+(0.5*Math.min(2, (Math.max(0, (a['treb_att']-1))*1.3))))); a['rg2']=Math.max((a['rg2']*0.87), (0.00+(0.5*Math.min(2, (Math.max(0, (a['mid_att']-1))*1.3))))); a['rg3']=Math.max((a['rg3']*0.87), (0.00+(0.5*Math.min(2, (Math.max(0, (a['bass_att']-1))*1.3))))); a['rg4']=Math.min(2, (Math.max(0, (a['mid_att']-1))*1.3)); a['q1']=a['rg1']; a['q2']=a['rg2']; a['q3']=a['rg3']; a['rg12']=Math.max((a['rg12']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['treb_att']-1))*1.3))))); a['rg22']=Math.max((a['rg22']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['mid_att']-1))*1.3))))); a['rg32']=Math.max((a['rg32']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['bass_att']-1))*1.3))))); a['rg_treb']=(a['rg_treb']+a['rg12']); a['rg_mid']=(a['rg_mid']+a['rg22']); a['rg_bass']=(a['rg_bass']+a['rg32']); a['q5']=a['rg_treb']; a['q6']=a['rg_mid']; a['q7']=a['rg_bass']; a['beat']=(((a['q5']+a['q6'])+a['q7'])*0.3333); a['q32']=a['beat']; a['rg13']=Math.max((a['rg13']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['treb_att']-1))*1.3))))); a['rg23']=Math.max((a['rg23']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['mid_att']-1))*1.3))))); a['rg33']=Math.max((a['rg33']*0.99), (0.02+(0.5*Math.min(3, (Math.max(0, (a['bass_att']-1))*1.3))))); a['q27']=((a['rg13']+a['rg23'])+a['rg33']); a['rg_mid2']=(a['rg_mid2']+a['rg23']); a['rg_treb2']=(a['rg_treb2']+a['rg13']); a['q9']=a['rg_mid2']; a['q10']=a['rg_treb2']; a['beat2']=(((a['rg13']+a['rg23'])+a['rg33'])*0.3333); a['q31']=a['beat2']; a['tic']=Math.min((a['time']-a['tin']), 0.1); a['tin']=a['time']; a['ra']=10; a['vav']=(a['tic']*((a['vav']*(div(1,a['tic'])-a['ra']))+((a['ra']*((a['bass']+a['treb'])+a['mid']))*0.33333))); a['vav2']=(a['tic']*((a['vav2']*(div(1,a['tic'])-a['ra']))+(((10*a['ra'])*((a['bass']+a['treb'])+a['mid']))*0.33333))); a['vt']=(a['vt']+(a['tic']*a['vav'])); a['monitor']=a['vav2']; a['q26']=a['vt']; a['n']=((Math.abs(((a['rg2']>0.7)?1:0))>0.00001)?((a['n']+1)):(a['n'])); a['n']=((Math.abs(((Math.abs((a['n'])-(4))<0.00001)?1:0))>0.00001)?(1):(a['n'])); a['q8']=a['n']; a['zoom']=(0.3+(0.04*Math.sin((0.340*a['time'])))); a['cameraposmul']=3; a['cameraxzspeed']=((a['q32']*0.05)+a['time']); a['lightzpos']=0; a['lightingpower']=(1+((0*1.1)*a['rg2'])); a['shadowstrength']=(0.9+(0*a['rg2'])); a['q29']=a['cameraposmul']; a['q25']=a['lightingpower']; a['q28']=a['lightzpos']; a['q24']=a['shadowstrength']; a['q22']=a['cameraxzspeed']; a['up']=0; a['q15']=a['up']; a['shakex']=((Math.abs(((Math.abs((a['up'])-(1))<0.00001)?1:0))>0.00001)?((0.150075*Math.sin((a['q26']*3)))):(0)); a['shakey']=((Math.abs(((Math.abs((a['up'])-(1))<0.00001)?1:0))>0.00001)?((0.150075*Math.cos((a['q26']*9)))):(0)); a['cameraposx']=(8*Math.cos((a['time']*0.4))); a['cameraposy']=((6+(4*Math.sin((a['time']*0.786))))+((0*6)*Math.cos((a['time']*0.312)))); a['cameraposz']=(8*Math.sin((a['time']*0.4))); a['cameraposx']=0; a['cameraposy']=20; a['cameraposz']=60; a['q19']=a['cameraposx']; a['q20']=a['cameraposy']; a['q21']=a['cameraposz']; a['lookatx']=(40*Math.sin((a['time']*0.416))); a['lookaty']=(45*Math.cos((a['time']*0.512))); a['lookatz']=0; a['q16']=a['lookatx']; a['q17']=a['lookaty']; a['q18']=a['lookatz']; a['zoom']=0.2; a['cameraoutsideoftorus']=-1; a['q14']=((Math.abs(((Math.abs((a['cameraoutsideoftorus'])-(1))<0.00001)?1:0))>0.00001)?(1):(-1)); a['torusrotspeed']=((0.4*a['time'])+((((a['q5']+a['q6'])+a['q7'])*0.333)*0.025)); a['torusrot']=((((0.2*a['time'])+Math.sin(a['torusrotspeed']))+Math.cos(a['torusrotspeed']))+(2*Math.cos((5*Math.sin((0.1*a['torusrotspeed'])))))); a['q13']=a['torusrot']; a['q23']=0; a['q12']=0; a['q30']=0; a['rg12']=Math.max((a['rg12']*0.9), (0.02+(0.5*Math.min(2, (Math.max(0, (a['treb_att']-1))*1.3))))); a['rg22']=Math.max((a['rg22']*0.9), (0.02+(0.5*Math.min(2, (Math.max(0, (a['mid_att']-1))*1.3))))); a['rg32']=Math.max((a['rg32']*0.9), (0.02+(0.5*Math.min(2, (Math.max(0, (a['bass_att']-1))*1.3))))); a['stars1speed']=(a['stars1speed']+((((a['rg12']+a['rg22'])+a['rg32'])*0.333)*0.06)); a['q10']=a['stars1speed']; a['stars2speed']=(a['stars1speed']*0.5); a['q11']=(a['stars2speed']*2); a['sunx']=(0+((0*0.03)*Math.sin((0.4*a['time'])))); a['suny']=(0+((0*0.04)*Math.cos((0.23*a['time'])))); a['q31']=a['sunx']; a['q32']=a['suny']; a['count']=mod(a['time'],20); a['monitor']=a['fps']; a['q23']=(0.5+(0.5*Math.sin(a['time']))); a['q12']=40; a['rot']=(0.4*Math.sin((a['time']*0.368)));}());","pixel_eqs_str":"","init_eqs_eel":"check1 = 1;\ncheck2 = 0;\ncheck3 = 0;\ncount = 1;","frame_eqs_eel":"PI = 3.141592654;\nwave_a=0;\nwarp = 0;\n\nrg1 = max(rg1*0.87, 0.00 + 0.5*min(2,max(0,treb_att-1)*1.3));\nrg2 = max(rg2*0.87, 0.00 + 0.5*min(2,max(0,mid_att-1)*1.3));\nrg3 = max(rg3*0.87, 0.00 + 0.5*min(2,max(0,bass_att-1)*1.3));\n\nrg4 = min(2,max(0,mid_att-1)*1.3);\n\nq1 = rg1;\nq2 = rg2;\nq3 = rg3;\n\nrg12 = max(rg12*0.99, 0.02 + 0.5*min(3,max(0,treb_att-1)*1.3));\nrg22 = max(rg22*0.99, 0.02 + 0.5*min(3,max(0,mid_att-1)*1.3));\nrg32 = max(rg32*0.99, 0.02 + 0.5*min(3,max(0,bass_att-1)*1.3));\n\n\nrg_treb = rg_treb + rg12;\nrg_mid = rg_mid + rg22;\nrg_bass = rg_bass + rg32;\n\nq5 = rg_treb;\nq6 = rg_mid;\nq7 = rg_bass;\n\nbeat = (q5 + q6 + q7)*0.3333;\nq32 = beat;\n\nrg13 = max(rg13*0.99, 0.02 + 0.5*min(3,max(0,treb_att-1)*1.3));\nrg23 = max(rg23*0.99, 0.02 + 0.5*min(3,max(0,mid_att-1)*1.3));\nrg33 = max(rg33*0.99, 0.02 + 0.5*min(3,max(0,bass_att-1)*1.3));\n\nq27 = rg13 + rg23 + rg33;\n\nrg_mid2 = rg_mid2 + rg23;\nrg_treb2 = rg_treb2 + rg13;\n\nq9 = rg_mid2;\nq10 = rg_treb2;\n\nbeat2 = (rg13 + rg23 + rg33)*0.3333;\nq31 = beat2;\n//beat3 = (rg1+rg2+rg3)*0.1;\n//q30 = beat3\n\ntic = min(time-tin,.1);\ntin = time;\nra = 10;\nvav = tic*(vav*(1/tic - ra) + ra*(bass+treb+mid)*.33333);\nvav2 = tic*(vav2*(1/tic - ra) + 10*ra*(bass+treb+mid)*.33333);\nvt = vt + tic*vav;\nmonitor = vav2;\nq26 = vt;\n\n\n//n = if(frame%13 == 0, n+1, n);\nn = if(rg2 > 0.7, n+1, n);\nn = if(n == 4, 1, n);\n\nq8 = n;\n\nzoom = 0.3 + 0.04*sin(0.340*time);\ncameraposmul = 3;\ncameraxzspeed = q32*0.05 + time;\nlightZpos = 0;\nlightingpower = 1 + 0*1.1*rg2;\nshadowstrength = .9 + 0*rg2;;\nq29 = cameraposmul;\nq25 = lightingpower;\nq28 = lightZpos;\nq24 = shadowstrength;\nq22 = cameraxzspeed;\n//rot = 1.1*sin(sin(0.2*time));\n\nup = 0;\nq15 = up;\nshakex = if(up == 1, 0.150075*sin(q26*3), 0);\nshakey = if(up == 1, 0.150075*cos(q26*9), 0);\ncameraposx = 8*cos(time*0.4);\ncameraposy = 6 + 4*sin(time*0.786) + 0*6*cos(time*0.312);\ncameraposz = 8*sin(time*0.4);\n//cameraposx = if(up == 1, 0 + shakex, cameraposx);\n//cameraposy = if(up == 1, 24 - 1.5*q27 + 0*4*sin(q26*0.7 + time*0.05), cameraposy);\n//cameraposz = if(up == 1, 0.00001 + shakey, cameraposz) + vav2*0.5*0;\ncameraposx = 0;\ncameraposy = 20 ;//3 + 2.5*sin(time);\ncameraposz = 60;\nq19 = cameraposx;\nq20 = cameraposy;\nq21 = cameraposz;\n\nlookatx = 40*sin(time*0.416);\nlookaty = 45*cos(time*0.512);\nlookatz = 0;\nq16 = lookatx;\nq17 = lookaty;\nq18 = lookatz;\nzoom = 0.2;\ncameraoutsideoftorus = -1;\nq14 = if(cameraoutsideoftorus == 1, 1, -1);\n\ntorusrotspeed = 0.4*time + (q5+q6+q7)*0.333 * 0.025;\ntorusrot = 0.2*time + sin(torusrotspeed) + cos(torusrotspeed) + 2*cos(5*sin(0.1*torusrotspeed));\nq13 = torusrot;\n\nq23 = 0;\nq12 = 0;\nq30 = 0;\n\n//####### stars speed #######//\nrg12 = max(rg12*0.9, 0.02 + 0.5*min(2,max(0,treb_att-1)*1.3));\nrg22 = max(rg22*0.9, 0.02 + 0.5*min(2,max(0,mid_att-1)*1.3));\nrg32 = max(rg32*0.9, 0.02 + 0.5*min(2,max(0,bass_att-1)*1.3));\nstars1speed = stars1speed + (rg12+rg22+rg32)*0.333*0.06;\nq10 = stars1speed;\nstars2speed = stars1speed*0.5;\nq11 = stars2speed*2;\n//####### stars speed #######//\n\nsunx = 0 + 0*0.03*sin(0.4*time);\nsuny= 0 + 0*0.04*cos(0.23*time);\nq31 = sunx;\nq32 = suny;\n\ncount = time%20;\nmonitor = fps;\n\nq23 = 0.5 + 0.5*sin(time);\nq12 = 40;\n\nrot = 0.4*sin(time*0.368);","pixel_eqs_eel":"","warp":"# define t time;\n# define PI 3.141592654\n# define MaxSteps 100 // max steps for ray marching\n\nvec3 torus1Pos() {return vec3(0,17.5,0);}\nvec2 torus1Size() {return vec2(45.3,17.5);}\n\nvec3 spherePos() {return vec3(0, 17.5, q12);} \n                         //+ 0.*vec3(0., sin(_pow(cos(0.75*time),2.)*cos(1.125*time)), 0.)\n                         //+ 0.*vec3(sin(time*0.4), 0., cos(time*0.4));}\nfloat sphereRad() {return 6.;}\n\nvec2 hexCoordsMul = vec2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nfloat tRadSpeed = time;\nfloat torusRotSpeed() {return time + 0.5*(q5*0.1 + q6*0.1 + q7*0.1);}\n\nvec3 camerapos() {return vec3(q19, q20, q21);}\nvec3 cameralookat() {return vec3(q16,q17,q18);}\nvec3 LightPos() {return camerapos()+vec3(0,0,-5);} //vec3(35*sin(time), 15, 35*cos(time)); //vec3(0,1.7 + 1.3*sin(0.3*q26),0); //vec3(sin(q26*4 + time*0.5)*8, 10 + 4*sin(time),cos(q26*2.5 + time*0.3)*8); //camerapos + 0*vec3(sin(time)*5,4,cos(time)*5) + 0*vec3(0,4.5 + 0*2.4*sin(time*0.3),0);\n\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\nvec3 GetTorus1Pos()\n{\n    vec3 pos = torus1Pos();\n    //pos = RotY(torus1Pos, time*2);\n    return pos;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0, 1);\n    return mix(b, a, h) - k*h*(1-h);\n}\nfloat fract(float a)\n{\n    return(a - floor(a));\n}\n\nvec2 fract(vec2 a)\n{\n    vec2 b = vec2(fract(a.x), fract(a.y));\n    return b;\n}\nvec3 fract(vec3 a)\n{\n    vec3 b = vec3(fract(a.xy), fract(a.z));\n    return b;\n}\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = (UV%r)-h;//mod(UV, r)-h;\n    vec2 b = ((UV-h)%r)-h;//mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec3 Hive(vec2 UV)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y  + 0*2.4*hc.y*sin(hc.z*hc.w)*cos(hc.z*hc.w));\n    //float c2 = smoothstep(0.01, 0.2, hc.y*0  + abs(hc.y*sin(hc.z*hc.w+q6*0.1 + 1.5*time)*cos(hc.z*hc.w+q6*0.1 + 1.5*time)));\n    //float c3 = smoothstep(0.01, 0.6, hc.y*0  + abs(hc.y*sin(hc.z*hc.w+q7*0.1 + 1.5*time)*cos(hc.z*hc.w+q7*0.1 + 1.5*time)));\n    //col = (1-c)*normalize(vec3(1,1,0.3))*1.5;\n    //col += c2*normalize(vec3(3,1.4,0));\n    //col += (1-c3)*normalize(vec3(4,1.4,0));\n    //return c;\n    \n    float b1 = 0.5 + 0.43*sin(hc.z*5 + hc.w*3 + 2*time);\n    float b2 = 0.5 + 0.5*cos(hc.y*65 + 3*time);\n     vec4 ehc = HexCoords((hc+0.1*vec2(0, time))*3*vec2(2.0693,2.5) + 100 + vec2(4,0));\n    float hexagons = smoothstep(0.,0.1, ehc.y)*((ehc.z)%2)*((ehc.w)%2);\n\n    float b3 = b1;/ \n    float eSquares = cos(hc.y*20 + time)*sin(hc.x*20 + time); // edges squares\n    eSquares = smoothstep(0,0.01,eSquares);\n    \n    float b4 = edges * eSquares;\n    //float b4 = edges * eHexagons;    \n\n    col = hexagons*(1-b3)*c*vec3(0.4274,0.847,0.8941) // azur color for the inverse of the waves\n          + b3*c*vec3(0.4078,0.1725,0.0705)  // brown color for the waves\n          + vec3(b3,0,(1-b3))*c*0.3          // add some rg colors to the waves and to the inverse of them\n          + b4*vec3(0.8431,0.7607,0.5019);   // brown-ish color for the ripples\n\n    //vec3 test = vec3(hc.zw*0.005,0);//everyOtherTile;\n\n    return col;\n}\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\nfloat sdTorus1(vec3 p, vec2 r, float a) {\n    float torusDist = length( vec2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    vec2 tUV = GetTorusUV(p, torus1Size());   \n    vec4 h = HexCoords(tUV*vec2(6,3.03) + 1000 + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.1,h.y) - 0.4*smoothstep(0.1,0.2,h.y); // + 0*(3*h.y)%2 + h.y*(sin(5*time) )*0  + 0.1*0 + 0*0.5*cos(h.y*10 + 0.3*q6);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = q14*hexTorus;\n    \n    float toreturn;\n    if(a == 1)\n        toreturn = holesTorus;\n    else \n        toreturn = hiveTorus;\n    return toreturn;\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r)\n{\n    vec2 sUV = GetSphereUV(p, r);\n    vec2 h = HexCoords(sUV*vec2(6.,3.3) + 100.);\n    float sphereDist = length(p)-r;\n    float hive = -0.25*smoothstep(0.,0.1,h.y) + 0.4*smoothstep(0.1,0.2,h.y);\n    float HexSphere = sphereDist + hive; // + 0.3*h.y*sin(h.y*15. + time) - h.y\n    return max(-sphereDist,HexSphere);\n}\nvec2 GetDist(vec3 p, float a)\n{\n    vec2 distToReturn; \n\n    // torus\n    vec3 torusPosNew = RotY(p - torus1Pos(), time);\n    //vec3 pNew = RotY(p, q26*1.5);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size(), a);\n    float torusID = 2;\n\n    // a sphere inside the torus\n    vec3 spherePosNew = RotZ(spherePos(), time); // rotate around the torus\n    //spherePosNew = RotY(spherePosNew, time);\n    // rotate around itself\n    //spherePosNew = RotZ(p - spherePosNew, time);\n    //spherePosNew = RotY(spherePosNew, time);\n    \n    float sphereDist = sdSphere(p-spherePos(), sphereRad());\n    float sphereID = 3.;\n    \n    float dist = torusDist;//min(torusDist, sphereDist);   \n\n    if(dist == torusDist)\n        distToReturn = vec2(torusDist, torusID);   \n    if(dist == sphereDist) \n        distToReturn = vec2(sphereDist, sphereID);\n    return distToReturn;\n}\nvec3 RayMarch(vec3 ro, vec3 rd, float steps, float a) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;  \n    float breakloop = 0;\n    for(int i = 0; i<steps && breakloop == 0; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p, a);\n        if(dS.x < 0.0001) {breakloop = 1; }\n        dO += dS.x*0.5;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p, float a)\n{\n    float d = GetDist(p, a).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy, a).x, \n                        GetDist(p-e.yxy, a).x, \n                        GetDist(p-e.yyx, a).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 n, vec3 lightpos, float lightpower, float shadowstrength, float steps, float a)\n{\n    //vec3 lightpos = LightPos;\n    //lightpos = camerapos;\n    vec3 l = normalize(lightpos - p);\n    //vec3 n = GetNormal(p, a);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    //dif = dot(n,l);\n    //float d = RayMarch(p + n*0.2, l, steps, a);\n    //if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    return dif;\n}\nfloat specularReflection(vec3 p, vec3 N, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    //vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n    \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n    \t}\n    return specular * intensity;\n}\nvec3 applyFog( vec3 rgb, float distance, float strength)\n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    vec3 fogColor = vec3(q3, 0, q2);//vec3(1., 0.3, 0.8);\n    return mix( rgb, fogColor, fogAmount );\n}\nfloat _pow(float b,float e){return pow(b,e);}\nvec2  _pow(vec2  b,float e){return pow(b,vec2(e));}\nvec3  _pow(vec3  b,float e){return pow(b,vec3(e));}\nvec4  _pow(vec4  b,float e){return pow(b,vec4(e));}\nshader_body\n{\n    vec2 uv_temp = uv;\n    uv-= 0.5;\n    uv.y*=-1;\n    uv *= aspect.xy;\n    \n    float rotspeed = 0;\n    rotspeed = 0.015*q5 + time*0.1;\n    \n    float beat = q32;    \n    vec3 col = vec3(0);\n \n    vec3 lookat = cameralookat();\n\n    float zoom = 1;\n    vec3 ro = camerapos();\n\n    //if(q15 == 1)\n    //    lookat = camerapos()*vec3(1,0,1) + 0.001;\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    float a = 0;\n    //float b = sin(time)*2;\n    //if(uv_temp.x > b) {a = 1;}\n    vec3 d = RayMarch(ro,rd, MaxSteps, a);\n    vec3 p = ro + rd*d.x;\n    \n    vec3 n = GetNormal(p, 0);\n    float dif = GetLight(p, n, LightPos(), 1, 0.4,  100, a); //***\n    float spRef = specularReflection(p, n, rd, LightPos(), 0.8, 10); \n    //float dif = 1;\n\n\n    if(d.z == 2) //torus1\n    {        \n        vec3 col;\n        vec2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n        col = Hive(tUV*vec2(6,3.03)+1000 + torusRotSpeed());\n        ret =dif;\n        ret =dif*col;\n    }\n    if(d.z == 3) //sphere\n    {\n        ret =dif;\n    }\n    ret *= ret*1.5;\n    ret += spRef;\n    ret =applyFog(ret, d.x, 0.01);\n   //ret =dif;\n    //ret =Hive(uv*3+10);\n}\n","comp":"#define sat saturate\nfloat glow, tmp, lamp, dist, bdist, b2dist, dist_c, smask;\nvec2 dz, uv1, uv3, uv4;\nconst vec3 CamPos = vec3(q4,q5,q6);\nconst float myzoom = q7,  res = 255, res2 = 64, tele = q16;\nconst mat3 RotMat = mat3(q20,q21,q22,q23,q24,q25,q26,q27,q28);\n\nvec2 fstep2 (vec2 xy) {return 1.0/res*round(res*xy);}\n\nfloat GetDist(vec2 uvi) {vec2 tmp; tmp = (texture (sampler_fc_main, uvi).gb); \nreturn 1.0078125-tmp.y -0.015625*tmp.x;} // = 1-(tmp.y + 1.0/res2*(tmp.x-.50));}\n\nfloat GetDistB(vec2 uvi)  {return 1-((texture(sampler_blur1, uvi).xyz * scale1) + bias1).b;}\nvec3 screen3;\nvec3 lavcol (float t) {return clamp(vec3(_pow(t,1),_pow(t,2.),_pow(t,5)), 0.0, 1.0);}\n\nvec3 t = vec3(q20,q23,q26);\nvec3 s = vec3(q21,q24,q27);\nvec3 ts = -cross(s,t);\nvec3 pos = vec3 (1,1,1);\n\nvec3 project (float dist) {  float z;\n  z = 18*dist/(screen3 * cross(ts,-t));\n  return vec3((cross(pos,screen3) * float2x3(ts,t))-z,-z);}\n\nfloat _pow(float b,float e){return pow(b,e);}\nvec2  _pow(vec2  b,float e){return pow(b,vec2(e));}\nvec3  _pow(vec3  b,float e){return pow(b,vec3(e));}\nvec4  _pow(vec4  b,float e){return pow(b,vec4(e));}\nshader_body {\nscreen3 = vec3 ((uv-.5)*aspect.xy,tele*0+1);\nvec3 uv2 = project(.1);\nvec3 sky = sat(lavcol (1-(abs(.3/uv2.z))))-.8;\n\nbdist = min(GetDist(uv),GetDistB(uv));;\n\nsky *= sat(1*bdist-2);\nret =sat(mix (1, sky, bdist));\n\nfloat struc = mix(texture(sampler_main, uv).xyz.r, ((texture(sampler_blur1, (uv-5)/5+5).xyz * scale1) + bias1).r,((texture(sampler_blur1, uv).xyz * scale1) + bias1).r-.8);\nret += lavcol(struc)*(.2-pow(bdist,1+5*mid_att));\n//ret =struc;\n}","warp_hlsl":"# define t time;\n# define PI 3.141592654\n# define MaxSteps 100 // max steps for ray marching\n\nfloat3 torus1Pos() {return float3(0,17.5,0);}\nfloat2 torus1Size() {return float2(45.3,17.5);}\n\nfloat3 spherePos() {return float3(0, 17.5, q12);} \n                         //+ 0.*float3(0., sin(pow(cos(0.75*time),2.)*cos(1.125*time)), 0.)\n                         //+ 0.*float3(sin(time*0.4), 0., cos(time*0.4));}\nfloat sphereRad() {return 6.;}\n\nfloat2 hexCoordsMul = float2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nstatic float tRadSpeed = time;\nfloat torusRotSpeed() {return time + 0.5*(q5*0.1 + q6*0.1 + q7*0.1);}\n\nfloat3 camerapos() {return float3(q19, q20, q21);}\nfloat3 cameralookat() {return float3(q16,q17,q18);}\nfloat3 LightPos() {return camerapos()+float3(0,0,-5);} //float3(35*sin(time), 15, 35*cos(time)); //float3(0,1.7 + 1.3*sin(0.3*q26),0); //float3(sin(q26*4 + time*0.5)*8, 10 + 4*sin(time),cos(q26*2.5 + time*0.3)*8); //camerapos + 0*float3(sin(time)*5,4,cos(time)*5) + 0*float3(0,4.5 + 0*2.4*sin(time*0.3),0);\n\n\nfloat3 RotX (float3 p, float speed)\n{\n    return float3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nfloat3 RotY (float3 p, float speed)\n{\n    return float3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nfloat3 RotZ (float3 p, float speed)\n{\n    return float3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\nfloat3 GetTorus1Pos()\n{\n    float3 pos = torus1Pos();\n    //pos = RotY(torus1Pos, time*2);\n    return pos;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0, 1);\n    return lerp(b, a, h) - k*h*(1-h);\n}\nfloat fract(float a)\n{\n    return(a - floor(a));\n}\n\nfloat2 fract(float2 a)\n{\n    float2 b = float2(fract(a.x), fract(a.y));\n    return b;\n}\nfloat3 fract(float3 a)\n{\n    float3 b = float3(fract(a.xy), fract(a.z));\n    return b;\n}\nfloat HexDist(float2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(float2(1,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\nfloat2 N22(float2 p)\n{\n    float3 a = fract(p.xyx*float3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(float2(a.x*a.y, a.y*a.z));\n}\nfloat4 HexCoords(float2 UV) \n{\n    \tfloat2 r = float2(1, 1.73);\n    float2 h = r*.5;\n    \n    float2 a = (UV%r)-h;//mod(UV, r)-h;\n    float2 b = ((UV-h)%r)-h;//mod(UV-h, r)-h;\n    \n    float2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan2(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    float2 id = UV - gv;\n    return float4(x, y, id.x,id.y);\n}\nfloat3 Hive(float2 UV)\n{\n    float3 col = 0;\n    float4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y  + 0*2.4*hc.y*sin(hc.z*hc.w)*cos(hc.z*hc.w));\n    //float c2 = smoothstep(0.01, 0.2, hc.y*0  + abs(hc.y*sin(hc.z*hc.w+q6*0.1 + 1.5*time)*cos(hc.z*hc.w+q6*0.1 + 1.5*time)));\n    //float c3 = smoothstep(0.01, 0.6, hc.y*0  + abs(hc.y*sin(hc.z*hc.w+q7*0.1 + 1.5*time)*cos(hc.z*hc.w+q7*0.1 + 1.5*time)));\n    //col = (1-c)*normalize(float3(1,1,0.3))*1.5;\n    //col += c2*normalize(float3(3,1.4,0));\n    //col += (1-c3)*normalize(float3(4,1.4,0));\n    //return c;\n    \n    float b1 = 0.5 + 0.43*sin(hc.z*5 + hc.w*3 + 2*time);\n    float b2 = 0.5 + 0.5*cos(hc.y*65 + 3*time);\n     float4 ehc = HexCoords((hc+0.1*float2(0, time))*3*float2(2.0693,2.5) + 100 + float2(4,0));\n    float hexagons = smoothstep(0.,0.1, ehc.y)*((ehc.z)%2)*((ehc.w)%2);\n\n    float b3 = b1;//*(1-hexagons);\n\n    float edges = 1-c;\n /*   float everyOtherTile = hc.z%2;\n    if( everyOtherTile == 0 ) {\n        everyOtherTile = 0; }\n    else if( everyOtherTile == 1 ) {\n        everyOtherTile = 1; }\n    else {everyOtherTile = 0.5;}\n */ \n    float eSquares = cos(hc.y*20 + time)*sin(hc.x*20 + time); // edges squares\n    eSquares = smoothstep(0,0.01,eSquares);\n    \n    float b4 = edges * eSquares;\n    //float b4 = edges * eHexagons;    \n\n    col = hexagons*(1-b3)*c*float3(0.4274,0.847,0.8941) // azur color for the inverse of the waves\n          + b3*c*float3(0.4078,0.1725,0.0705)  // brown color for the waves\n          + float3(b3,0,(1-b3))*c*0.3          // add some rg colors to the waves and to the inverse of them\n          + b4*float3(0.8431,0.7607,0.5019);   // brown-ish color for the ripples\n\n    //float3 test = float3(hc.zw*0.005,0);//everyOtherTile;\n\n    return col;\n}\nfloat2 GetTorusUV(float3 p, float2 torusSize)\n{\n    float x = atan2(p.x, p.z);\n    float y = atan2(length(p.xz)-torusSize.x, p.y);\n    return float2(x,y);    \n}\nfloat sdTorus1(float3 p, float2 r, float a) {\n    float torusDist = length( float2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    float2 tUV = GetTorusUV(p, torus1Size());   \n    float4 h = HexCoords(tUV*float2(6,3.03) + 1000 + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.1,h.y) - 0.4*smoothstep(0.1,0.2,h.y); // + 0*(3*h.y)%2 + h.y*(sin(5*time) )*0  + 0.1*0 + 0*0.5*cos(h.y*10 + 0.3*q6);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = q14*hexTorus;\n    \n    float toreturn;\n    if(a == 1)\n        toreturn = holesTorus;\n    else \n        toreturn = hiveTorus;\n    return toreturn;\n}\nfloat2 GetSphereUV(float3 p, float r)\n{\n    float3 n = normalize(p);\n    float x = atan2(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return float2(x,y);\n}\nfloat sdSphere( float3 p, float r)\n{\n    float2 sUV = GetSphereUV(p, r);\n    float2 h = HexCoords(sUV*float2(6.,3.3) + 100.);\n    float sphereDist = length(p)-r;\n    float hive = -0.25*smoothstep(0.,0.1,h.y) + 0.4*smoothstep(0.1,0.2,h.y);\n    float HexSphere = sphereDist + hive; // + 0.3*h.y*sin(h.y*15. + time) - h.y\n    return max(-sphereDist,HexSphere);\n}\nfloat2 GetDist(float3 p, float a)\n{\n    float2 distToReturn; \n\n    // torus\n    float3 torusPosNew = RotY(p - torus1Pos(), time);\n    //float3 pNew = RotY(p, q26*1.5);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size(), a);\n    float torusID = 2;\n\n    // a sphere inside the torus\n    float3 spherePosNew = RotZ(spherePos(), time); // rotate around the torus\n    //spherePosNew = RotY(spherePosNew, time);\n    // rotate around itself\n    //spherePosNew = RotZ(p - spherePosNew, time);\n    //spherePosNew = RotY(spherePosNew, time);\n    \n    float sphereDist = sdSphere(p-spherePos(), sphereRad());\n    float sphereID = 3.;\n    \n    float dist = torusDist;//min(torusDist, sphereDist);   \n\n    if(dist == torusDist)\n        distToReturn = float2(torusDist, torusID);   \n    if(dist == sphereDist) \n        distToReturn = float2(sphereDist, sphereID);\n    return distToReturn;\n}\nfloat3 RayMarch(float3 ro, float3 rd, float steps, float a) \n{\n    float2 dS;\n    float dO;\n    float3 p;  \n    float breakloop = 0;\n    for(int i = 0; i<steps && breakloop == 0; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p, a);\n        if(dS.x < 0.0001) {breakloop = 1; }\n        dO += dS.x*0.5;\n    }     \n    return float3(dO,dS);\n}\nfloat3 GetNormal(float3 p, float a)\n{\n    float d = GetDist(p, a).x;\n    float2 e = float2(.01, 0);\n \n    float3 n = d-float3(GetDist(p-e.xyy, a).x, \n                        GetDist(p-e.yxy, a).x, \n                        GetDist(p-e.yyx, a).x);\n    return normalize(n);\n}\nfloat GetLight(float3 p, float3 n, float3 lightpos, float lightpower, float shadowstrength, float steps, float a)\n{\n    //float3 lightpos = LightPos;\n    //lightpos = camerapos;\n    float3 l = normalize(lightpos - p);\n    //float3 n = GetNormal(p, a);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    //dif = dot(n,l);\n    //float d = RayMarch(p + n*0.2, l, steps, a);\n    //if(d < length(lightpos-p)) {dif *= shadowstrength;}\n    return dif;\n}\nfloat specularReflection(float3 p, float3 N, float3 rd, float3 lightPos, float intensity, float shininessVal)\n{\n    //float3 N = GetNormal(p);\n    float3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n    \tif(lambertian > 0.0) {\n        float3 R = reflect(-L, N);      // Reflected light vector\n        float3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n    \t}\n    return specular * intensity;\n}\nfloat3 applyFog( float3 rgb, float distance, float strength)\n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    float3 fogColor = float3(q3, 0, q2);//float3(1., 0.3, 0.8);\n    return lerp( rgb, fogColor, fogAmount );\n}\nshader_body\n{\n    float2 uv_temp = uv;\n    uv-= 0.5;\n    uv.y*=-1;\n    uv *= aspect.xy;\n    \n    float rotspeed = 0;\n    rotspeed = 0.015*q5 + time*0.1;\n    \n    float beat = q32;    \n    float3 col = 0;\n \n    float3 lookat = cameralookat();\n\n    float zoom = 1;\n    float3 ro = camerapos();\n\n    //if(q15 == 1)\n    //    lookat = camerapos()*float3(1,0,1) + 0.001;\n\n    float3 F = normalize(lookat-ro); // Forward\n    float3 R = normalize(cross(float3(0., 1., 0.), F)); //Right\n    float3 U = cross(F, R); //Up\n\n    float3 C = ro + F*zoom;\n    float3 I = C + uv.x*R + uv.y*U;\n    float3 rd = normalize(I-ro);\n\n    float a = 0;\n    //float b = sin(time)*2;\n    //if(uv_temp.x > b) {a = 1;}\n    float3 d = RayMarch(ro,rd, MaxSteps, a);\n    float3 p = ro + rd*d.x;\n    \n    float3 n = GetNormal(p, 0);\n    float dif = GetLight(p, n, LightPos(), 1, 0.4,  100, a); //***\n    float spRef = specularReflection(p, n, rd, LightPos(), 0.8, 10); \n    //float dif = 1;\n\n\n    if(d.z == 2) //torus1\n    {        \n        float3 col;\n        float2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n        col = Hive(tUV*float2(6,3.03)+1000 + torusRotSpeed());\n        ret = dif;\n        ret = dif*col;\n    }\n    if(d.z == 3) //sphere\n    {\n        ret = dif;\n    }\n    ret *= ret*1.5;\n    ret += spRef;\n    ret = applyFog(ret, d.x, 0.01);\n   //ret = dif;\n    //ret = Hive(uv*3+10);\n}\n","comp_hlsl":"#define sat saturate\nfloat glow, tmp, lamp, dist, bdist, b2dist, dist_c, smask;\nfloat2 dz, uv1, uv3, uv4;\nstatic const float3 CamPos = float3(q4,q5,q6);\nstatic const float myzoom = q7,  res = 255, res2 = 64, tele = q16;\nstatic const float3x3 RotMat = float3x3(q20,q21,q22,q23,q24,q25,q26,q27,q28);\n\nfloat2 fstep2 (float2 xy) {return 1.0/res*round(res*xy);}\n\nfloat GetDist(float2 uvi) {float2 tmp; tmp = (tex2D (sampler_fc_main, uvi).gb); \nreturn 1.0078125-tmp.y -0.015625*tmp.x;} // = 1-(tmp.y + 1.0/res2*(tmp.x-.50));}\n\nfloat GetDistB(float2 uvi)  {return 1-GetBlur1(uvi).b;}\nfloat3 screen3;\nfloat3 lavcol (float t) {return saturate(float3(pow(t,1),pow(t,2.),pow(t,5)));}\n\nstatic float3 t = float3(q20,q23,q26);\nstatic float3 s = float3(q21,q24,q27);\nstatic float3 ts = -cross(s,t);\nstatic float3 pos = float3 (1,1,1);\n\nfloat3 project (float dist) {  float z;\n  z = 18*dist/mul(cross(ts,-t),screen3);\n  return float3(mul(float2x3(ts,t),cross(pos,screen3))-z,-z);}\n\nshader_body {\nscreen3 = float3 ((uv-.5)*aspect.xy,tele*0+1);\nfloat3 uv2 = project(.1);\nfloat3 sky = sat(lavcol (1-(abs(.3/uv2.z))))-.8;\n\nbdist = min(GetDist(uv),GetDistB(uv));;\n\nsky *= sat(1*bdist-2);\nret = sat(lerp (1, sky, bdist));\n\nfloat struc = lerp(GetPixel(uv).r, GetBlur1((uv-5)/5+5).r,GetBlur1(uv).r-.8);\nret += lavcol(struc)*(.2-pow(bdist,1+5*mid_att));\n//ret = struc;\n}"}