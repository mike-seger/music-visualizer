{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":7,"additivewave":1,"wave_thick":1,"wave_brighten":0,"wrap":0,"brighten":1,"darken":1,"wave_a":3.2,"wave_scale":1.768,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpanimspeed":0.01,"warpscale":0.009,"fshader":1,"cx":0.465,"warp":0.0096,"ob_size":0,"ob_r":0.123,"ob_b":0.1,"ib_size":0,"ib_r":0,"ib_g":0,"ib_b":0,"mv_x":64,"mv_y":1.248,"mv_l":5,"mv_b":0,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"usedots":1,"thick":1},"init_eqs_str":"(function(){a['xp'] = 0; a['s'] = 0; a['brightness'] = 0; a['yp'] = 0; a['t1'] = 0; a['advance'] = 0; a['x_screen'] = 0; a['star_size'] = 0; a['y_screen'] = 0; a['zp'] = 0; a['dist'] = 0; }())","frame_eqs_str":"(function(){a['advance']=(a['advance']+0.003); a['advance']=((Math.abs(above(a['advance'], 2))>0.00001)?(0):(a['advance'])); a['t1']=a['advance'];}())","point_eqs_str":"(function(){a['s']=(a['sample']*6.28); a['xp']=((((Math.sin(a['s'])+Math.sin((a['s']*0.34)))+Math.sin((a['s']*24.3)))+Math.sin((a['s']*13.8)))+Math.sin((a['s']*7.2))); a['xp']=(a['xp']*0.25); a['yp']=((((Math.cos(a['s'])+Math.sin((a['s']*0.24)))+Math.cos((a['s']*17.4)))+Math.sin((a['s']*37.7)))+Math.cos((a['s']*9.1))); a['yp']=(a['yp']*0.25); a['zp']=((((Math.cos(a['s'])+Math.cos((a['s']*5.24)))+Math.cos((a['s']*47.4)))+Math.cos((a['s']*27.7)))+Math.sin((a['s']*12.3))); a['zp']=(a['zp']*0.3); a['zp']=((a['zp']+1)-a['t1']); a['zp']=((Math.abs(below(a['zp'], 0))>0.00001)?((a['zp']+2)):(a['zp'])); a['star_size']=(0.8+(0.4*Math.sin((a['s']*5.0)))); a['a']=((1-(a['zp']*3))*(0.8+(0.4*Math.sin((a['s']*3.0))))); a['zp']=(a['zp']*0.9); a['x_screen']=(div(-a['xp'],a['zp'])+0.5); a['y_screen']=(div(-a['yp'],a['zp'])+0.5); a['r']=(0.7+(0.3*Math.sin(((a['s']*1.5)+1.0)))); a['g']=(0.7+(0.3*Math.sin(((a['s']*2.0)+2.0)))); a['b']=(0.7+(0.3*Math.sin(((a['s']*2.5)+3.0)))); a['dist']=sqrt((((a['x']-a['x_screen'])*(a['x']-a['x_screen']))+((a['y']-a['y_screen'])*(a['y']-a['y_screen'])))); a['brightness']=1.0; a['r']=(a['r']*a['brightness']); a['g']=(a['g']*a['brightness']); a['b']=(a['b']*a['brightness']); a['x']=a['x_screen']; a['y']=a['y_screen'];}())","init_eqs_eel":"","frame_eqs_eel":"advance=advance+ 0.003;\nadvance=if( above(advance,2) , 0, advance);\nt1=advance","point_eqs_eel":"s = sample * 6.28;\n\n// Random x position (modified for more variation)\nxp = sin(s) + sin(s*0.34) + sin(s*24.3) + sin(s*13.8) + sin(s*7.2);\nxp = xp * 0.25;\n\n// Random y position (modified for more variation)\nyp = cos(s) + sin(s*0.24) + cos(s*17.4) + sin(s*37.7) + cos(s*9.1);\nyp = yp * 0.25;\n\n// Random z position (modified for depth variation)\nzp = cos(s) + cos(s*5.24) + cos(s*47.4) + cos(s*27.7) + sin(s*12.3);\nzp = zp * 0.3;\n\n// Pull stars toward screen\nzp = zp + 1 - t1;\n\n// Correct when below 0\nzp = if(below(zp, 0), zp + 2, zp);\n\n// Star size & brightness adjustment (bigger stars)\nstar_size = 0.8 + 0.4 * sin(s*5.0); // Varying star size\na = (1 - zp*3) * (0.8 + 0.4 * sin(s*3.0)); // Brighter stars\n\nzp = zp * 0.9;\n\nx_screen = -xp/zp + 0.5;\ny_screen = -yp/zp + 0.5;\n\n// Random colors based on sample position\nr = 0.7 + 0.3 * sin(s * 1.5 + 1.0);\ng = 0.7 + 0.3 * sin(s * 2.0 + 2.0);\nb = 0.7 + 0.3 * sin(s * 2.5 + 3.0);\n\n// Apply star size effect (makes stars appear bigger)\ndist = sqrt((x - x_screen)*(x - x_screen) + (y - y_screen)*(y - y_screen));\nbrightness = 1.0;\n\n// Final color with brightness\nr = r * brightness;\ng = g * brightness;\nb = b * brightness;\n\nx = x_screen;\ny = y_screen;"},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    //SHADER MILKDROP2077+AI\n\n    vec3 col = vec3(0,0,0);\n    uv = (uv_orig - 0.5) * aspect.xy;\n    \n    const float FAR = 80.0;\n    const int count = 70;\n    const float T = time * 0.25;\n    const float PI = 3.14159265359;\n    const float TWO_PI = 6.28318530718;\n    \n    for(int i = 0; i < count; i++) {\n        float v = float(i+1)/float(count);\n        float fi = float(i);\n        \n        // Optimized random number generation\n        float rnd = fract(fi/30.0 + (0.5+v*TWO_PI)*PI);\n        float rnd2 = fract(rnd*100.0);\n        float rnd3 = fract(rnd+rnd2);\n        \n        // Precompute common terms\n        float angle1 = rnd*TWO_PI + v;\n        float angle2 = rnd2*TWO_PI - v;\n        float rnd_sum = rnd + rnd2;\n        \n        // Star position calculations (optimized trig)\n        float x = cos(angle1) * (rnd + 1.0) * PI;\n        float y = sin(angle2) * (rnd2 + rnd + 1.0) * PI;\n        float z = fract(-T*(rnd_sum*0.5)*PI*(0.5+v)) * (0.001+v)*FAR;\n        \n        // Star rendering\n        float z_inv = 1.0/z;  // Reciprocal for faster division\n        vec2 starPos = vec2(x,y) * z_inv;\n        float dist_sq = dot(uv-starPos, uv-starPos);  // Avoid sqrt with distance squared\n        float s = clamp(mix(0.001, 0.009, rnd2) * inversesqrt(max(1e-8, dist_sq)), 0.0, 1.0);\n        s *= smoothstep(v, 0.25, abs(z*0.0125));  // 1/FAR = 0.0125\n        \n        // Color accumulation (optimized)\n        col += s * vec3(rnd, rnd2, rnd3);\n    }\n    \n    ret = vec4(col, 1.0);\n}","comp":"#define sat saturate\nfloat glow, tmp, lamp, dist, bdist, b2dist, dist_c, smask;\nvec2 dz, uv1, uv3, uv4;\nconst vec3 CamPos = vec3(q4,q5,q6);\nconst float myzoom = q7,  res = 255, res2 = 64, tele = q16;\nconst mat3 RotMat = mat3(q20,q21,q22,q23,q24,q25,q26,q27,q28);\n\nvec2 fstep2 (vec2 xy) {return 1.0/res*round(res*xy);}\n\nfloat GetDist(vec2 uvi) {vec2 tmp; tmp = (texture (sampler_fc_main, uvi).gb); \nreturn 1.0078125-tmp.y -0.015625*tmp.x;} // = 1-(tmp.y + 1.0/res2*(tmp.x-.50));}\n\nfloat GetDistB(vec2 uvi)  {return 1-((texture(sampler_blur1, uvi).xyz * scale1) + bias1).b;}\nvec3 screen3;\nvec3 lavcol (float t) {return clamp(vec3(pow(t,1),pow(t,2.),pow(t,5)), 0.0, 1.0);}\n\nvec3 t = vec3(q20,q23,q26);\nvec3 s = vec3(q21,q24,q27);\nvec3 ts = -cross(s,t);\nvec3 pos = vec3 (1,1,1);\n\nvec3 project (float dist) {  float z;\n  z = 18*dist/(screen3 * cross(ts,-t));\n  return vec3((cross(pos,screen3) * float2x3(ts,t))-z,-z);}\n\nshader_body {\nscreen3 = vec3 ((uv-.5)*aspect.xy,tele*0+1);\nvec3 uv2 = project(.1);\nvec3 sky = sat(lavcol (1-(abs(.3/uv2.z))))-.8;\n\nbdist = min(GetDist(uv),GetDistB(uv));;\n\nsky *= sat(1*bdist-2);\nret = sat(mix (1, sky, bdist));\n\nfloat struc = mix(texture(sampler_main, uv).xyz.r, ((texture(sampler_blur1, (uv-5)/5+5).xyz * scale1) + bias1).r,((texture(sampler_blur1, uv).xyz * scale1) + bias1).r-.8);\nret += lavcol(struc)*(.2-pow(bdist,1+5*mid_att));\n//ret = struc;\nret*=2.5;\nret-=0.4;\n}","warp_hlsl":"shader_body\n{\n    //SHADER MILKDROP2077+AI\n\n    float3 col = float3(0,0,0);\n    uv = (uv_orig - 0.5) * aspect.xy;\n    \n    const float FAR = 80.0;\n    const int count = 70;\n    const float T = time * 0.25;\n    const float PI = 3.14159265359;\n    const float TWO_PI = 6.28318530718;\n    \n    for(int i = 0; i < count; i++) {\n        float v = float(i+1)/float(count);\n        float fi = float(i);\n        \n        // Optimized random number generation\n        float rnd = frac(fi/30.0 + (0.5+v*TWO_PI)*PI);\n        float rnd2 = frac(rnd*100.0);\n        float rnd3 = frac(rnd+rnd2);\n        \n        // Precompute common terms\n        float angle1 = rnd*TWO_PI + v;\n        float angle2 = rnd2*TWO_PI - v;\n        float rnd_sum = rnd + rnd2;\n        \n        // Star position calculations (optimized trig)\n        float x = cos(angle1) * (rnd + 1.0) * PI;\n        float y = sin(angle2) * (rnd2 + rnd + 1.0) * PI;\n        float z = frac(-T*(rnd_sum*0.5)*PI*(0.5+v)) * (0.001+v)*FAR;\n        \n        // Star rendering\n        float z_inv = 1.0/z;  // Reciprocal for faster division\n        float2 starPos = float2(x,y) * z_inv;\n        float dist_sq = dot(uv-starPos, uv-starPos);  // Avoid sqrt with distance squared\n        float s = clamp(lerp(0.001, 0.009, rnd2) * rsqrt(max(1e-8, dist_sq)), 0.0, 1.0);\n        s *= smoothstep(v, 0.25, abs(z*0.0125));  // 1/FAR = 0.0125\n        \n        // Color accumulation (optimized)\n        col += s * float3(rnd, rnd2, rnd3);\n    }\n    \n    ret = float4(col, 1.0);\n}","comp_hlsl":"#define sat saturate\nfloat glow, tmp, lamp, dist, bdist, b2dist, dist_c, smask;\nfloat2 dz, uv1, uv3, uv4;\nstatic const float3 CamPos = float3(q4,q5,q6);\nstatic const float myzoom = q7,  res = 255, res2 = 64, tele = q16;\nstatic const float3x3 RotMat = float3x3(q20,q21,q22,q23,q24,q25,q26,q27,q28);\n\nfloat2 fstep2 (float2 xy) {return 1.0/res*round(res*xy);}\n\nfloat GetDist(float2 uvi) {float2 tmp; tmp = (tex2D (sampler_fc_main, uvi).gb); \nreturn 1.0078125-tmp.y -0.015625*tmp.x;} // = 1-(tmp.y + 1.0/res2*(tmp.x-.50));}\n\nfloat GetDistB(float2 uvi)  {return 1-GetBlur1(uvi).b;}\nfloat3 screen3;\nfloat3 lavcol (float t) {return saturate(float3(pow(t,1),pow(t,2.),pow(t,5)));}\n\nstatic float3 t = float3(q20,q23,q26);\nstatic float3 s = float3(q21,q24,q27);\nstatic float3 ts = -cross(s,t);\nstatic float3 pos = float3 (1,1,1);\n\nfloat3 project (float dist) {  float z;\n  z = 18*dist/mul(cross(ts,-t),screen3);\n  return float3(mul(float2x3(ts,t),cross(pos,screen3))-z,-z);}\n\nshader_body {\nscreen3 = float3 ((uv-.5)*aspect.xy,tele*0+1);\nfloat3 uv2 = project(.1);\nfloat3 sky = sat(lavcol (1-(abs(.3/uv2.z))))-.8;\n\nbdist = min(GetDist(uv),GetDistB(uv));;\n\nsky *= sat(1*bdist-2);\nret = sat(lerp (1, sky, bdist));\n\nfloat struc = lerp(GetPixel(uv).r, GetBlur1((uv-5)/5+5).r,GetBlur1(uv).r-.8);\nret += lavcol(struc)*(.2-pow(bdist,1+5*mid_att));\n//ret = struc;\nret*=2.5;\nret-=0.4;\n}"}