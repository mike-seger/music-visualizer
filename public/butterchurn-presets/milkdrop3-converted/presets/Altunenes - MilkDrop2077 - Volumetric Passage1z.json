{"version":2,"baseVals":{"rating":5,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":15,"additivewave":1,"wave_thick":1,"wrap":0,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":0.625,"wave_smoothing":0.9,"modwavealphastart":0.88,"modwavealphaend":1.98,"warpanimspeed":1.459,"warpscale":2.007,"fshader":1,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":0,"ib_g":0,"ib_b":0,"mv_x":64,"mv_y":48,"mv_l":1,"mv_r":1.06,"mv_b":0.819,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['st'] = 0; a['ranx'] = 0; a['q15'] = 0; a['q6'] = 0; a['posx'] = 0; a['st_'] = 0; a['q11'] = 0; a['q10'] = 0; a['posy'] = 0; a['q4'] = 0; a['rany'] = 0; a['dir'] = 0; a['q16'] = 0; a['q2'] = 0; a['q3'] = 0; a['t0'] = 0; a['dec'] = 0; a['view'] = 0; a['q7'] = 0; a['test'] = 0; a['q8'] = 0; a['n']=0; for(var mdparser_idx21=0;mdparser_idx21<100000;mdparser_idx21++){a['megabuf'][Math.floor(a['n'])]=0; a['gmegabuf'][Math.floor(a['n'])]=0; a['n']+=1;} a['posx']=rand(10); a['posy']=rand(10); a['ranx']=rand(1); a['rany']=rand(1); a['ranh']=rand(10); a['t0']=a['time']; a['st']=0.5; a['st_']=0.5;}())","frame_eqs_str":"(function(){a['st']=Math.max(0, (a['st']-div(0.2,a['fps']))); a['dec']=(1-div(0.5,a['fps'])); a['st_']=((a['st_']*a['dec'])+((1-a['dec'])*a['st'])); a['dir']=(0.7*Math.sin(((a['time']*0.0162)+(a['rany']*6)))); a['q2']=(a['dir']+0.5); a['q3']=Math.sin(a['dir']); a['q4']=Math.cos(a['dir']); a['q7']=0.002; a['posx']=(a['time']*0.0003); a['posy']=(a['time']*0.004); a['q10']=a['posx']; a['q11']=a['posy']; a['q15']=a['ranx']; a['q16']=a['rany']; a['test']=(((a['t0']-a['time'])*0.047)-div(3.14,2)); a['view']=(0.7+(Math.min(1, Math.max(-1, (2*Math.sin(a['test']))))*0.17)); a['q8']=((4+(3*Math.sin(a['test'])))+((a['view']-0.55)*16)); a['q6']=((a['view']*(1-a['st_']))+(a['st_']*2)); a['monitor']=a['view'];}())","pixel_eqs_str":"","init_eqs_eel":"n = 0;\nloop (100000,megabuf(n)=0;gmegabuf(n)=0;n += 1;);\n\nposx = rand(10); posy = rand(10);\nranx = rand (1); rany = rand(1);\nranh = rand(10);\nt0 = time;\nst = 0.5; st_=0.5;","frame_eqs_eel":"st = max (0, st-0.2/fps);\ndec = 1-0.5/fps;\nst_ = st_* (dec) + (1-dec)*st;\n\n//dir\ndir = 0.7*sin(time*.0162+rany*6);\nq2 = dir+0.5; \nq3 = sin(dir);\nq4 = cos(dir);\n\n//scaling plane\nq7 = 0.002;\n\n//movement\nposx = time*0.0003;\nposy = time*0.004;\nq10 = posx;\nq11 = posy;\n\n//start ran for warp mod \nq15 = ranx;\nq16 = rany;\n\ntest = (t0-time)*0.047-3.14/2;\nview = 0.7 + min(1, max (-1, 2*sin(test)))*0.17;\n\n//Alti\nq8 = 4 + 3* sin(test) + (view-0.55)*16;\n\n//hory (Kippung)\nq6 = view * (1-st_) + st_*2;\n\n//q6  = 0.55;\nmonitor = view;","pixel_eqs_eel":"","warp":"//Shader by Altunenes\n//https://www.shadertoy.com/view/w33GRl\n//Ported to MilkDrop by MilkDrop2077\n\n// Noise function\nfloat n(vec2 p) {\n   return sin(p.x*3.0+sin(p.y*2.7))*cos(p.y*1.1+cos(p.x*2.3));\n}\n\n// Fractal function\nfloat f(vec3 p) {\n    float v = 0.0, a = 1.0;\n    for(int i=0; i<7; i++) {\n       v += n(p.xy+p.z*0.5)*a;\n       p *= 2.0;\n       a *= 0.5;\n    }\n    return v;\n}\n\nshader_body {\n    // Initialize output\n    ret = vec4(0, 0, 0, 1);\n\n    // Coordinate setup with aspect ratio correction\n    float aspect = aspect.x/aspect.y;\n    uv = (uv.xy-0.5)*vec2(aspect,1.0);\n    vec3 o = vec3(0,0,0);\n    float z = 0.0, d = 0.0, t = time;\n    float N = 0.0;\n\n    // Raymarching loop\n    for(int i=0; i<50; i++) {\n        // Ray setup\n        vec3 p = z*normalize(vec3(uv.x, uv.y, 1.0));\n        p.z += t;\n\n        // Rotation matrix inspired by mrange's work\n        float angle = p.z;\n        mat2 R = mat2(cos(angle), -sin(angle),\n                             sin(angle), cos(angle));\n        p.xy = (R * p.xy);\n\n        // Fractal evaluation\n        N = f(p+q1/2 + t*0.1)*q3;\n        d = length(p.xy)-1.0+N*0.3;\n        p.z = fmod(p.z,4.0+cos(q1))-3.0;\n        d = abs(d)+0.01;\n\n        // Color composition\n        vec3 c = vec3(0.1,0.3,0.8)/(length(p.xy+N+bass_att)*0.5);\n        c += vec3(bass_att*0.6,0.4,0.2)/(length(p.xz+N)*0.5);\n        c += vec3(1.0,1.0,2.0)*(0.5+0.5*sin(N*1.0+t));\n\n        // Accumulate color with falloff\n        o += c/d*0.12;\n        z += d*0.6;\n    }\n\n    // Final color processing\n    ret.rgb = tanh(o*0.001);\n}","comp":"shader_body\n{\n    ret = texture(sampler_main, uv).xyz;\nret*=2;\n//ret-=0.2;\n//MilkDrop3 Rainbow Mode:\nret *= 1*normalize ((texture (sampler_noise_hq,(uv+q4/2)/6).xyz));\n}","warp_hlsl":"//Shader by Altunenes\n//https://www.shadertoy.com/view/w33GRl\n//Ported to MilkDrop by MilkDrop2077\n\n// Noise function\nfloat n(float2 p) {\n   return sin(p.x*3.0+sin(p.y*2.7))*cos(p.y*1.1+cos(p.x*2.3));\n}\n\n// Fractal function\nfloat f(float3 p) {\n    float v = 0.0, a = 1.0;\n    for(int i=0; i<7; i++) {\n       v += n(p.xy+p.z*0.5)*a;\n       p *= 2.0;\n       a *= 0.5;\n    }\n    return v;\n}\n\nshader_body {\n    // Initialize output\n    ret = float4(0, 0, 0, 1);\n\n    // Coordinate setup with aspect ratio correction\n    float aspect = aspect.x/aspect.y;\n    uv = (uv.xy-0.5)*float2(aspect,1.0);\n    float3 o = float3(0,0,0);\n    float z = 0.0, d = 0.0, t = time;\n    float N = 0.0;\n\n    // Raymarching loop\n    for(int i=0; i<50; i++) {\n        // Ray setup\n        float3 p = z*normalize(float3(uv.x, uv.y, 1.0));\n        p.z += t;\n\n        // Rotation matrix inspired by mrange's work\n        float angle = p.z;\n        float2x2 R = float2x2(cos(angle), -sin(angle),\n                             sin(angle), cos(angle));\n        p.xy = mul(p.xy, R);\n\n        // Fractal evaluation\n        N = f(p+q1/2 + t*0.1)*q3;\n        d = length(p.xy)-1.0+N*0.3;\n        p.z = fmod(p.z,4.0+cos(q1))-3.0;\n        d = abs(d)+0.01;\n\n        // Color composition\n        float3 c = float3(0.1,0.3,0.8)/(length(p.xy+N+bass_att)*0.5);\n        c += float3(bass_att*0.6,0.4,0.2)/(length(p.xz+N)*0.5);\n        c += float3(1.0,1.0,2.0)*(0.5+0.5*sin(N*1.0+t));\n\n        // Accumulate color with falloff\n        o += c/d*0.12;\n        z += d*0.6;\n    }\n\n    // Final color processing\n    ret.rgb = tanh(o*0.001);\n}","comp_hlsl":"shader_body\n{\n    ret = tex2D(sampler_main, uv).xyz;\nret*=2;\n//ret-=0.2;\n//MilkDrop3 Rainbow Mode:\nret *= 1*normalize ((tex2D (sampler_noise_hq,(uv+q4/2)/6)));\n}"}