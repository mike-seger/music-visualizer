{"version":2,"baseVals":{"rating":4,"decay":1,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"wave_mode":9,"wave_brighten":0,"wrap":0,"invert":1,"wave_a":100,"wave_scale":0.081,"wave_smoothing":0,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpanimspeed":1.459,"warpscale":2.007,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_b":0,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":0,"ib_g":0,"ib_b":0,"mv_x":64,"mv_y":48,"mv_l":5,"mv_b":0,"mv_a":0},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['st'] = 0; a['ranx'] = 0; a['q15'] = 0; a['q6'] = 0; a['posx'] = 0; a['st_'] = 0; a['q11'] = 0; a['q10'] = 0; a['posy'] = 0; a['q4'] = 0; a['rany'] = 0; a['dir'] = 0; a['q16'] = 0; a['q2'] = 0; a['q3'] = 0; a['t0'] = 0; a['dec'] = 0; a['view'] = 0; a['q7'] = 0; a['test'] = 0; a['q8'] = 0; a['n']=0; for(var mdparser_idx43=0;mdparser_idx43<100000;mdparser_idx43++){a['megabuf'][Math.floor(a['n'])]=0; a['gmegabuf'][Math.floor(a['n'])]=0; a['n']+=1;} a['posx']=rand(10); a['posy']=rand(10); a['ranx']=rand(1); a['rany']=rand(1); a['ranh']=rand(10); a['t0']=a['time']; a['st']=0.15; a['st_']=0.05;}());","frame_eqs_str":"(function(){a['st']=Math.max(0, (a['st']-div(0.2,a['fps']))); a['dec']=(1-div(0.5,a['fps'])); a['st_']=((a['st_']*a['dec'])+((1-a['dec'])*a['st'])); a['dir']=(0.7*Math.sin(((a['time']*0.0162)+(a['rany']*6)))); a['q2']=(a['dir']+0.5); a['q3']=Math.sin(a['dir']); a['q4']=Math.cos(a['dir']); a['q7']=0.002; a['posx']=(a['time']*0.00103); a['posy']=(a['time']*0.0074); a['q10']=a['posx']; a['q11']=a['posy']; a['q15']=a['ranx']; a['q16']=a['rany']; a['test']=(((a['t0']-a['time'])*0.047)-div(3.14,2)); a['view']=(0.7+(Math.min(1, Math.max(-1, (2*Math.sin(a['test']))))*0.17)); a['q8']=((4+(3*Math.sin(a['test'])))+((a['view']-0.55)*16)); a['q6']=((a['view']*(1-a['st_']))+(a['st_']*2)); a['monitor']=a['view'];}());","pixel_eqs_str":"","init_eqs_eel":"n = 0;\nloop (100000,megabuf(n)=0;gmegabuf(n)=0;n += 1;);\n\nposx = rand(10); posy = rand(10);\nranx = rand (1); rany = rand(1);\nranh = rand(10);\nt0 = time;\nst = 0.15; st_=0.05;","frame_eqs_eel":"st = max (0, st-0.2/fps);\ndec = 1-0.5/fps;\nst_ = st_* (dec) + (1-dec)*st;\n\n//dir\ndir = 0.7*sin(time*.0162+rany*6);\nq2 = dir+0.5; \nq3 = sin(dir);\nq4 = cos(dir);\n\n//scaling plane\nq7 = 0.002;\n\n//movement\nposx = time*0.00103;\nposy = time*0.0074;\nq10 = posx;\nq11 = posy;\n\n//start ran for warp mod \nq15 = ranx;\nq16 = rany;\n\ntest = (t0-time)*0.047-3.14/2;\nview = 0.7 + min(1, max (-1, 2*sin(test)))*0.17;\n\n//Alti\nq8 = 4 + 3* sin(test) + (view-0.55)*16;\n\n//hory (Kippung)\nq6 = view * (1-st_) + st_*2;\n\n//q6  = 0.55;\nmonitor = view;","pixel_eqs_eel":"","warp":"#define sat saturate\nuniform sampler2D sampler_pw_noise_lq;\nconst float quality = 4;\nvec3 rsl, rsl3, ret1, sky, mod;\nvec2 dz, uv0, uv1, uv2, uv3, uv4, uvc, dz1;\nfloat  lav_gnd,lav_gnd2, smask, ripple, l,d,i,p;\nconst float hory = q6, xyscale = q7, alti = q8;\nconst vec2 hor = texsize.zw*vec2 (1.5,0), dir = vec2 (q3, q4), modran = vec2 (q15,q16);\nconst vec3 mov = vec3 (q10,q11,0);\nfloat comb (vec2 uvi) {return dot (texture(sampler_noise_lq, uvi).yx, vec2(1,1));}\n\nvec2 noise2 (vec2 uvi) {vec2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= 1-texture(sampler_noise_lq,uvi*s).xyz; s*= 3;}\n  return tmp;}\n\n\nvec2 noise3 (vec3 uvi, vec3 mod) {uvi *= 0.16; vec2 tmp = 1; float s = 1; float diff = 0;\n  uvi.xy+= modran*3;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= sat(1-texture(sampler_noise_lq,uvi*s).xyz*(0.8+mod.y/2)/s); s*= 3+tmp*0.002*mod.z;}\n  for (int n = 1; n <= 3; n +=1 ) {tmp *= sat(1-texture(sampler_noise_lq,uvi*s).xyz*(0.8+mod.y/2)/s); s*= 3;}\n  diff = sat (16-2*uvi.z-20000* abs (tmp.x-0.4)) ;\n  tmp  -= diff*0.009 ;\n  return 1-pow (tmp,0.8+mod.x);}\n\nvec2 enoise3 (vec2 uvi, vec3 mod) {uvi/=6; vec2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 6; n +=1 ) {tmp *= 1-texture(sampler_noise_lq,uvi*s).xyz/(0.8+mod.y)/s; s*= 2.9;}\n  if ((tmp.x > 0.398) && (tmp.x < 0.402)) {tmp = 0.398;}\n  return 1-pow (tmp,.8+2*mod.x);}\n\nvec3 rs_lav (vec2 uvi, float berg) {  float z; vec2 rs;\n  z = 1/(uvi.y+hory)*(alti-berg*16); //z = clamp(z,0,4/xyscale);\n  rs.x = uvi.x * 2*z ; rs.y = z; \n  return vec3(rs*xyscale,z); }\n\n\nshader_body {\nuv1=uv-0.5;\nlav_gnd=  -min (texture(sampler_fc_main,uv).b, texture(sampler_fc_main,uv+hor.yx).b);\n\nrsl = rs_lav(uv1,lav_gnd)+mov; \nmod = texture(sampler_noise_mq,rsl.xy*.043+modran).xyz;\n\ni=0, p=0;\nfor (int n=1; n <= quality; n++) {\n  p =  ((lav_gnd+noise3 (rsl, mod))/quality);\n  i += p;\n  lav_gnd -= p*0.1+i*0.2; \n  rsl = rs_lav(uv1,lav_gnd)+mov; \n}\nl = clamp(-lav_gnd, 0.0, 1.0);\n\nd=1.5;\ndz = -1.2/rsl.z*xyscale*d*dir;\n\nrsl3 = rsl * 8 + l*0;\nripple = ((noise2 (rsl3-dz) - noise2 (rsl3+dz))* (1-l))*1+0.02;\n\nripple = (1.2/rsl.z*ripple+noise3 (rsl-vec3 (dz,0),mod) - noise3 (rsl+vec3 (dz,0),mod))*(1-l)/d/sqrt(50+rsl.z)*3001;\n\nripple = .95-exp(-ripple);\n\nret.r = ripple;\nret.b = l;\nret = mix(ret,((texture(sampler_blur1, uv).xyz * scale1) + bias1),0.2);\nret.g = rsl.z*xyscale*4;\n}","comp":"#define sat saturate\nfloat dist, struc, height,snow;\nvec2 dz, dz1, uv0, uv1, uv3;\nvec3 rsl, mod, ret0;\nfloat  lav_gnd;\nconst float hory = q6, xyscale = q7, alti = q8, dir = q2;\nconst vec2 modran = vec2 (q15,q16);\n\nconst vec2 hor = texsize.zw*vec2 (1,0);;\nconst vec2 ver = texsize.zw*vec2 (0,1);;\nconst vec3 mov = vec3 (q10,q11,0);\n\nvec2 noise2 (vec2 uvi, float h) {vec2 tmp = 0; float s = 1;\n  for (int n = 1; n <= 3; n +=1 ) {tmp += texture(sampler_noise_mq,(uvi)*s+time*0.003).xyz/s; s*= 3+h*-0.0;}\n  return sat (abs(tmp*-1)-0.2);}\n\nvec3 rs_lav (vec2 uvi, float berg) {  float z; vec2 rs;\n  z = 1/(uvi.y+hory)*(alti-berg*16); //z = clamp(z,0,4/xyscale);\n  rs.x = uvi.x * 2*z ; rs.y = z; \n  return vec3(rs*xyscale,z)+mov*1; }\n\nvec3 GetBlur0 (vec2 uvi)\n {return (texture(sampler_main, uvi).xyz + texture(sampler_main, uvi +hor).xyz + texture(sampler_main, uvi -hor).xyz + texture(sampler_main, uvi +ver).xyz + texture(sampler_main, uvi -ver).xyz)/5; }\n\n\nshader_body {\n//uv += texsize.zw/2;\nuv0 = uv;\nrsl = rs_lav (uv-0.5,-((texture(sampler_blur1, uv).xyz * scale1) + bias1).b+modran.yx);\nmod = texture(sampler_noise_mq, rsl*0.1).xyz;\n\nret0 = texture(sampler_main, uv).xyz;\ndist = ret0.g;\nstruc = ret0.r;\nheight = 1-ret0.b;\nsnow = abs (height-((texture(sampler_blur1, uv).xyz * scale1) + bias1).b)* (2*height*(0.0+struc))/dist*1;\n\n//###########################\nret = ret0;;\n\nret.r = mix (ret0.r,((texture(sampler_blur1, uv).xyz * scale1) + bias1).r,sat(2-6*(ret0.g+ret0.b*0.25))) ;\n\nret.b = pow (ret0.b,3)/2 + ret.r/2;\nret.g = pow (ret0.g,1.2) /2+ ret.r/2;\nret.rg = sat (ret.rg+lum(ret)/2) + ret.b*(mod.z-0.3)*0.5;\n\nret += ret0.r *pow (height,2)* vec3 (1, 1, 2)*2*sat(2-dist)*mod.x; //snow\n//ret += snow;\n\n\nret *= 1;\n\n//wolken\nrsl = rs_lav (uv-0.5,- sat(((texture(sampler_blur1, uv).xyz * scale1) + bias1).b*0.7));\nret += noise2(3*rsl,((texture(sampler_blur1, uv).xyz * scale1) + bias1).b).x * clamp(4*ret0.b-3, 0.0, 1.0) / abs(rsl.z)*3*mod.y;\n\n//Sonne\nret += sat(0.12/sqrt (length (uv-vec2 (q2,0.58-q6))) * clamp(1-height*1 + dist*2-1, 0.0, 1.0)) ;\n//ret += pow (mix (1-uv.x,uv.x,dir)*(1-uv.y),4) * clamp(texture(sampler_main, uv).xyz.b*5 +texture(sampler_main, uv).xyz.g*2-1, 0.0, 1.0) * vec3(1,0.5,0.14);\n\n\n\n}\nret = pow (struc, vec3 (1,1.5,1.26));;\nret = mix (ret, 1, pow(1-height,3));\nret = mix (ret, vec3 (0,0.5,.1), sat(dist*1));\n\n","warp_hlsl":"#define sat saturate\nsampler sampler_pw_noise_lq;\nstatic const float quality = 4;\nfloat3 rsl, rsl3, ret1, sky, mod;\nfloat2 dz, uv0, uv1, uv2, uv3, uv4, uvc, dz1;\nfloat  lav_gnd,lav_gnd2, smask, ripple, l,d,i,p;\nstatic const float hory = q6, xyscale = q7, alti = q8;\nstatic const float2 hor = texsize.zw*float2 (1.5,0), dir = float2 (q3, q4), modran = float2 (q15,q16);\nstatic const float3 mov = float3 (q10,q11,0);\nfloat comb (float2 uvi) {return dot (tex2D(sampler_noise_lq, uvi).yx, float2(1,1));}\n\nfloat2 noise2 (float2 uvi) {float2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= 1-tex2D(sampler_noise_lq,uvi*s); s*= 3;}\n  return tmp;}\n\n\nfloat2 noise3 (float3 uvi, float3 mod) {uvi *= 0.16; float2 tmp = 1; float s = 1; float diff = 0;\n  uvi.xy+= modran*3;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= sat(1-tex2D(sampler_noise_lq,uvi*s)*(0.8+mod.y/2)/s); s*= 3+tmp*0.002*mod.z;}\n  for (int n = 1; n <= 3; n +=1 ) {tmp *= sat(1-tex2D(sampler_noise_lq,uvi*s)*(0.8+mod.y/2)/s); s*= 3;}\n  diff = sat (16-2*uvi.z-20000* abs (tmp.x-0.4)) ;\n  tmp  -= diff*0.009 ;\n  return 1-pow (tmp,0.8+mod.x);}\n\nfloat2 enoise3 (float2 uvi, float3 mod) {uvi/=6; float2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 6; n +=1 ) {tmp *= 1-tex2D(sampler_noise_lq,uvi*s)/(0.8+mod.y)/s; s*= 2.9;}\n  if ((tmp.x > 0.398) && (tmp.x < 0.402)) {tmp = 0.398;}\n  return 1-pow (tmp,.8+2*mod.x);}\n\nfloat3 rs_lav (float2 uvi, float berg) {  float z; float2 rs;\n  z = 1/(uvi.y+hory)*(alti-berg*16); //z = clamp(z,0,4/xyscale);\n  rs.x = uvi.x * 2*z ; rs.y = z; \n  return float3(rs*xyscale,z); }\n\n\nshader_body {\nuv1=uv-0.5;\nlav_gnd=  -min (tex2D(sampler_fc_main,uv).b, tex2D(sampler_fc_main,uv+hor.yx).b);\n\nrsl = rs_lav(uv1,lav_gnd)+mov; \nmod = tex2D(sampler_noise_mq,rsl.xy*.043+modran);\n\ni=0, p=0;\nfor (int n=1; n <= quality; n++) {\n  p =  ((lav_gnd+noise3 (rsl, mod))/quality);\n  i += p;\n  lav_gnd -= p*0.1+i*0.2; \n  rsl = rs_lav(uv1,lav_gnd)+mov; \n}\nl = saturate(-lav_gnd);\n\nd=1.5;\ndz = -1.2/rsl.z*xyscale*d*dir;\n\nrsl3 = rsl * 8 + l*0;\nripple = ((noise2 (rsl3-dz) - noise2 (rsl3+dz))* (1-l))*1+0.02;\n\nripple = (1.2/rsl.z*ripple+noise3 (rsl-float3 (dz,0),mod) - noise3 (rsl+float3 (dz,0),mod))*(1-l)/d/sqrt(50+rsl.z)*3001;\n\nripple = .95-exp(-ripple);\n\nret.r = ripple;\nret.b = l;\nret = lerp(ret,GetBlur1(uv),0.2);\nret.g = rsl.z*xyscale*4;\n}","comp_hlsl":"#define sat saturate\nfloat dist, struc, height,snow;\nfloat2 dz, dz1, uv0, uv1, uv3;\nfloat3 rsl, mod, ret0;\nfloat  lav_gnd;\nstatic const float hory = q6, xyscale = q7, alti = q8, dir = q2;\nstatic const float2 modran = float2 (q15,q16);\n\nstatic const float2 hor = texsize.zw*float2 (1,0);;\nstatic const float2 ver = texsize.zw*float2 (0,1);;\nstatic const float3 mov = float3 (q10,q11,0);\n\nfloat2 noise2 (float2 uvi, float h) {float2 tmp = 0; float s = 1;\n  for (int n = 1; n <= 3; n +=1 ) {tmp += tex2D(sampler_noise_mq,(uvi)*s+time*0.003)/s; s*= 3+h*-0.0;}\n  return sat (abs(tmp*-1)-0.2);}\n\nfloat3 rs_lav (float2 uvi, float berg) {  float z; float2 rs;\n  z = 1/(uvi.y+hory)*(alti-berg*16); //z = clamp(z,0,4/xyscale);\n  rs.x = uvi.x * 2*z ; rs.y = z; \n  return float3(rs*xyscale,z)+mov*1; }\n\nfloat3 GetBlur0 (float2 uvi)\n {return (GetPixel(uvi) + GetPixel(uvi +hor) + GetPixel(uvi -hor) + GetPixel(uvi +ver) + GetPixel(uvi -ver))/5; }\n\n\nshader_body {\n//uv += texsize.zw/2;\nuv0 = uv;\nrsl = rs_lav (uv-0.5,-GetBlur1(uv).b+modran.yx);\nmod = tex2D(sampler_noise_mq, rsl*0.1);\n\nret0 = GetPixel(uv);\ndist = ret0.g;\nstruc = ret0.r;\nheight = 1-ret0.b;\nsnow = abs (height-GetBlur1(uv).b)* (2*height*(0.0+struc))/dist*1;\n\n//###########################\nret = ret0;;\n\nret.r = lerp (ret0.r,GetBlur1(uv).r,sat(2-6*(ret0.g+ret0.b*0.25))) ;\n\nret.b = pow (ret0.b,3)/2 + ret.r/2;\nret.g = pow (ret0.g,1.2) /2+ ret.r/2;\nret.rg = sat (ret.rg+lum(ret)/2) + ret.b*(mod.z-0.3)*0.5;\n\nret += ret0.r *pow (height,2)* float3 (1, 1, 2)*2*sat(2-dist)*mod.x; //snow\n//ret += snow;\n\n\nret *= 1;\n\n//wolken\nrsl = rs_lav (uv-0.5,- sat(GetBlur1(uv).b*0.7));\nret += noise2(3*rsl,GetBlur1(uv).b).x * saturate (4*ret0.b-3) / abs(rsl.z)*3*mod.y;\n\n//Sonne\nret += sat(0.12/sqrt (length (uv-float2 (q2,0.58-q6))) * saturate (1-height*1 + dist*2-1)) ;\n//ret += pow (lerp (1-uv.x,uv.x,dir)*(1-uv.y),4) * saturate (GetPixel(uv).b*5 +GetPixel(uv).g*2-1) * float3(1,0.5,0.14);\n\n\n\n}\nret = pow (struc, float3 (1,1.5,1.26));;\nret = lerp (ret, 1, pow(1-height,3));\nret = lerp (ret, float3 (0,0.5,.1), sat(dist*1));\n\n"}