{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":4,"wave_dots":1,"wave_brighten":0,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":0.012,"wave_smoothing":0.9,"warpscale":1.331,"fshader":1,"zoom":0.9995,"warp":0.009,"wave_r":0.5,"wave_g":0.4,"wave_b":0.3,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":1,"mv_r":0.39,"mv_g":0.44,"mv_b":0.9,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"usedots":1,"thick":1,"additive":1,"r":0.3,"g":0.7},"init_eqs_str":"(function(){a['s'] = 0; a['xp'] = 0; a['yp'] = 0; a['zp'] = 0; a['t1'] = 0; a['x_screen'] = 0; a['y_screen'] = 0; a['advance'] = 0; }());","frame_eqs_str":"(function(){a['advance']=(a['advance']+0.005); a['advance']=((Math.abs(above(a['advance'], 2))>0.00001)?(0):(a['advance'])); a['t1']=a['advance'];}());","point_eqs_str":"(function(){a['s']=(a['sample']*6.28); a['xp']=(((Math.sin(a['s'])+Math.sin((a['s']*0.34)))+Math.sin((a['s']*24.3)))+Math.sin((a['s']*13.8))); a['xp']=(a['xp']*0.20); a['yp']=(((Math.cos(a['s'])+Math.sin((a['s']*0.24)))+Math.cos((a['s']*17.4)))+Math.sin((a['s']*37.7))); a['yp']=(a['yp']*0.20); a['zp']=(((Math.cos(a['s'])+Math.cos((a['s']*5.24)))+Math.cos((a['s']*47.4)))+Math.cos((a['s']*27.7))); a['zp']=(a['zp']*0.25); a['zp']=((a['zp']+1)-a['t1']); a['zp']=((Math.abs(below(a['zp'], 0))>0.00001)?((a['zp']+2)):(a['zp'])); a['a']=(1-(a['zp']*0.5)); a['zp']=(a['zp']*0.7); a['x_screen']=(div(a['xp'],a['zp'])+0.5); a['y_screen']=(div(a['yp'],a['zp'])+0.5); a['x']=a['x_screen']; a['y']=a['y_screen']; a['r']=1; a['g']=1; a['b']=1;}());","init_eqs_eel":"","frame_eqs_eel":"advance=advance+ 0.005;\nadvance=if( above(advance,2) , 0, advance);\nt1=advance","point_eqs_eel":"s=sample*6.28;\n\n//plot random x position via function of sample pos;\nxp=sin(s)+sin(s*0.34)+sin(s*24.3)+sin(s*13.8);\nxp=xp*0.20;\n\n//plot random y position via function of sample pos;\nyp=cos(s)+sin(s*0.24)+cos(s*17.4)+sin(s*37.7);\nyp=yp*0.20;\n\n//plot random z position via function of sample pos;\nzp=cos(s)+cos(s*5.24)+cos(s*47.4)+cos(s*27.7);\nzp=zp*0.25;\n\n//pull stars toward screen\nzp=zp + 1 - t1;\n\n//correct when below 0\nzp=if( below(zp,0) , zp+2 , zp );\n\n//darken far stars\na=(1 - zp*0.5);\n\nzp=zp*0.7;\n\nx_screen=xp/zp + 0.5;\ny_screen=yp/zp + 0.5;\n\nx=x_screen;\ny=y_screen;\n\nr=1;\ng=1;\nb=1;\n\n"},{"baseVals":{"enabled":1,"usedots":1,"thick":1},"init_eqs_str":"(function(){a['s'] = 0; a['xp'] = 0; a['yp'] = 0; a['zp'] = 0; a['t1'] = 0; a['x_screen'] = 0; a['y_screen'] = 0; a['advance'] = 0; }());","frame_eqs_str":"(function(){a['advance']=(a['advance']+0.005); a['advance']=((Math.abs(above(a['advance'], 2))>0.00001)?(0):(a['advance'])); a['t1']=a['advance'];}());","point_eqs_str":"(function(){a['s']=(a['sample']*6.28); a['xp']=(((Math.sin(a['s'])+Math.sin((a['s']*0.34)))+Math.sin((a['s']*24.3)))+Math.sin((a['s']*13.8))); a['xp']=(a['xp']*0.20); a['yp']=(((Math.cos(a['s'])+Math.sin((a['s']*0.24)))+Math.cos((a['s']*17.4)))+Math.sin((a['s']*37.7))); a['yp']=(a['yp']*0.20); a['zp']=(((Math.cos(a['s'])+Math.cos((a['s']*5.24)))+Math.cos((a['s']*47.4)))+Math.cos((a['s']*27.7))); a['zp']=(a['zp']*0.25); a['zp']=((a['zp']+1)-a['t1']); a['zp']=((Math.abs(below(a['zp'], 0))>0.00001)?((a['zp']+2)):(a['zp'])); a['a']=(1-(a['zp']*0.5)); a['zp']=(a['zp']*0.7); a['x_screen']=(div(-a['xp'],a['zp'])+0.5); a['y_screen']=(div(-a['yp'],a['zp'])+0.5); a['x']=a['x_screen']; a['y']=a['y_screen']; a['r']=1; a['g']=1; a['b']=1;}());","init_eqs_eel":"","frame_eqs_eel":"advance=advance+ 0.005;\nadvance=if( above(advance,2) , 0, advance);\nt1=advance","point_eqs_eel":"s=sample*6.28;\n\n//plot random x position via function of sample pos;\nxp=sin(s)+sin(s*0.34)+sin(s*24.3)+sin(s*13.8);\nxp=xp*0.20;\n\n//plot random y position via function of sample pos;\nyp=cos(s)+sin(s*0.24)+cos(s*17.4)+sin(s*37.7);\nyp=yp*0.20;\n\n//plot random z position via function of sample pos;\nzp=cos(s)+cos(s*5.24)+cos(s*47.4)+cos(s*27.7);\nzp=zp*0.25;\n\n//pull stars toward screen\nzp=zp + 1 - t1;\n\n//correct when below 0\nzp=if( below(zp,0) , zp+2 , zp );\n\n//darken far stars\na=(1 - zp*0.5);\n\nzp=zp*0.7;\n\nx_screen=-xp/zp + 0.5;\ny_screen=-yp/zp + 0.5;\n\nx=x_screen;\ny=y_screen;\n\nr=1;\ng=1;\nb=1;\n\n"},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"float _pow(float b,float e){return pow(b,e);}\nvec2  _pow(vec2  b,float e){return pow(b,vec2(e));}\nvec3  _pow(vec3  b,float e){return pow(b,vec3(e));}\nvec4  _pow(vec4  b,float e){return pow(b,vec4(e));}\nshader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.02;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const vec2 p = uv * PI2 - 250.0;\n    vec2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const vec2 i_plus_t = i + time/2;\n        const vec2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x);\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const vec2 pd = vec2(p.x/denom, p.y/denom2);\n        c += inversesqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - _pow(c, 1.4);\n    const vec3 colour = _pow(abs(c), 8.0);\n    ret =vec4(colour, 1.0).xyz;\n}","comp":"\nshader_body {\n\n    //Don't drink and drive, take LSD and teleport\n    ret =texture(sampler_main, uv).xyz;\n    \n    // Time-varying color using cosine waves\n    vec3 col = 0.8 + 0.5 * cos(time/5 + vec3(uv.x, uv.y, uv.x) + vec3(0, 2, 4));\n    \n    // Output final color mixing with the old frame\n    ret =ret * 1.5/(bass_att) * vec4(col, 1.0);\n\n}","warp_hlsl":"shader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.02;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const float2 p = uv * PI2 - 250.0;\n    float2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const float2 i_plus_t = i + time/2;\n        const float2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x);\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const float2 pd = float2(p.x/denom, p.y/denom2);\n        c += rsqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - pow(c, 1.4);\n    const float3 colour = pow(abs(c), 8.0);\n    ret = float4(colour, 1.0);\n}","comp_hlsl":"\nshader_body {\n\n    //Don't drink and drive, take LSD and teleport\n    ret = tex2D(sampler_main, uv).xyz;\n    \n    // Time-varying color using cosine waves\n    float3 col = 0.8 + 0.5 * cos(time/5 + float3(uv.x, uv.y, uv.x) + float3(0, 2, 4));\n    \n    // Output final color mixing with the old frame\n    ret = ret * 1.5/(bass_att) * float4(col, 1.0);\n\n}"}