{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":15,"additivewave":1,"wave_thick":1,"wrap":0,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":0.625,"wave_smoothing":0.9,"modwavealphastart":0.88,"modwavealphaend":1.98,"warpscale":1.331,"fshader":1,"zoom":1.00496,"warp":0.00016,"sx":0.99967,"sy":0.9999,"wave_r":0,"wave_g":0,"wave_b":0,"mv_x":64,"mv_y":48,"mv_l":1,"mv_r":1.06,"mv_b":0.819,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['red_value'] = 0; a['blue_value'] = 0; a['green_value'] = 0; a['q1'] = 0; a['q2'] = 0; a['q3'] = 0; a['q4'] = 0;}())","frame_eqs_str":"(function(){a['red_value']=((Math.abs(above(a['bass'], 1.15))>0.00001)?(((3*(1-a['bass']))+Math.abs((Math.sin((a['time']*0.3))*0.1)))):(((Math.abs(above(a['treb'], 1.0))>0.00001)?(0):((div(Math.sin(div(a['time'],2.5)),10)+0.65))))); a['blue_value']=((Math.abs(above(a['bass'], 1.15))>0.00001)?((0.5+Math.abs((Math.sin((a['time']*0.3))*0.1)))):(((Math.abs(above(a['treb'], 1.0))>0.00001)?((0.7+(0.1*Math.sin((a['time']*1.123))))):(((0.3-a['treb'])-div(Math.sin(div(a['time'],2.5)),10)))))); a['green_value']=((Math.abs(above(a['bass'], 1.15))>0.00001)?((1-Math.abs((Math.sin((a['time']*0.3))*0.1)))):(((Math.abs(above(a['treb'], 1.0))>0.00001)?((0.6+(0.1*Math.sin((a['time']*1.123))))):((div(Math.sin(div(a['time'],2.5)),10)+0.3))))); a['wave_r']=a['red_value']; a['wave_b']=a['blue_value']; a['wave_g']=a['green_value']; a['q1']=(((a['cx']*2)-1)+(0.62*((0.60*Math.sin((0.374*a['time'])))+(0.40*Math.sin((0.294*a['time'])))))); a['q2']=(((a['cy']*2)-1)+(0.62*((0.60*Math.sin((0.393*a['time'])))+(0.40*Math.sin((0.223*a['time'])))))); a['q3']=(((a['cx']*2)-1)+(0.62*((0.60*Math.sin((0.174*-a['time'])))+(0.40*Math.sin((0.364*a['time'])))))); a['q4']=(((a['cy']*2)-1)+(0.62*((0.60*Math.sin((0.234*a['time'])))+(0.40*Math.sin((0.271*-a['time'])))))); a['decay']=(a['decay']-(0.01*equal(mod(a['frame'],5), 0)));}())","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"red_value = if(above(bass,1.15),3*(1-bass)+abs(sin(time*0.3)*0.1),if(above(treb,1.0),0, sin(time/2.5)/10+0.65));\nblue_value = if(above(bass,1.15),0.5+abs(sin(time*0.3)*0.1),if(above(treb,1.0),0.7+0.1*sin(time*1.123), 0.3-treb-sin(time/2.5)/10));\ngreen_value = if(above(bass,1.15),1-abs(sin(time*0.3)*0.1),if(above(treb,1.0),0.6+0.1*sin(time*1.123), sin(time/2.5)/10+0.3));\nwave_r = red_value;\nwave_b= blue_value;\nwave_g = green_value;\nq1 = (cx*2-1) + 0.62*( 0.60*sin(0.374*time) + 0.40*sin(0.294*time) );\nq2 = (cy*2-1) + 0.62*( 0.60*sin(0.393*time) + 0.40*sin(0.223*time) );\nq3 = (cx*2-1) + 0.62*( 0.60*sin(0.174*-time) + 0.40*sin(0.364*time) );\nq4 = (cy*2-1) + 0.62*( 0.60*sin(0.234*time) + 0.40*sin(0.271*-time) );\ndecay = decay - 0.01*equal(frame%5,0);","pixel_eqs_eel":"//rot = q8;","warp":"shader_body\n{\n    // Shader By XorDev (x.com/XorDev)\n    // Ported to MilkDrop by MilkDrop2077\n\n    // Get screen coordinates\n    vec2 fragCoord = uv * texsize;\n    vec2 r = texsize;\n    vec3 FC = vec3(fragCoord, bass_att);\n\n    float PI = 3.80132711084;\n    float PI2 = PI * 1.9;\n    float t = time;\n\n    // Initialize output\n    vec4 o = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Main shader logic\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    float i = 0.0;\n    float z = 0.0;\n    float f = 0.0;\n\n    // Outer loop - 30 iterations\n    for(int iter = 0; iter < 30; iter++) {\n        i += 1.0;\n\n        // Update z and calculate distance field\n        f = 0.002 + abs(length(p.xy) - 3.8 + q1 + dot(cos(p), sin(p/4).yzx)) / 8;\n        z += f;\n\n        // Add to output color\n        o += (1.8 + sin(i * 0.2 * treb_att/6 + z + t + vec4(5.0, 1.0, 2.0, 0.0))) / f/4;\n\n        // Update ray position\n        p = z * normalize(FC.rgb * 2.0 + q3 - vec3(r.x, r.y, r.y));\n        p.z -= t;\n\n        // Inner loop - 6 iterations for fractal detail\n        for(int j = 1; j <= 6; j++) {\n            f = float(j*2);\n            p += sin(round(p.yxz * PI2) / PI * f + t * 0.5 + bass_att/16) / f;\n        }\n    }\n\n    // Apply final transformation\n    o = tanh(o / 1000.0);\n\n    // Output final color\n    ret = o.rgb;\n}\n","comp":"shader_body\n{\n//MilkDrop3 Flip Mode:\n//uv = 1-uv;\n\n ret = texture(sampler_main, uv).xyz;\n}","warp_hlsl":"shader_body\n{\n    // Shader By XorDev (x.com/XorDev)\n    // Ported to MilkDrop by MilkDrop2077\n\n    // Get screen coordinates\n    float2 fragCoord = uv * texsize;\n    float2 r = texsize;\n    float3 FC = float3(fragCoord, bass_att);\n\n    float PI = 3.80132711084;\n    float PI2 = PI * 1.9;\n    float t = time;\n\n    // Initialize output\n    float4 o = float4(0.0, 0.0, 0.0, 0.0);\n\n    // Main shader logic\n    float3 p = float3(0.0, 0.0, 0.0);\n    float i = 0.0;\n    float z = 0.0;\n    float f = 0.0;\n\n    // Outer loop - 30 iterations\n    for(int iter = 0; iter < 30; iter++) {\n        i += 1.0;\n\n        // Update z and calculate distance field\n        f = 0.002 + abs(length(p.xy) - 3.8 + q1 + dot(cos(p), sin(p/4).yzx)) / 8;\n        z += f;\n\n        // Add to output color\n        o += (1.8 + sin(i * 0.2 * treb_att/6 + z + t + float4(5.0, 1.0, 2.0, 0.0))) / f/4;\n\n        // Update ray position\n        p = z * normalize(FC.rgb * 2.0 + q3 - float3(r.x, r.y, r.y));\n        p.z -= t;\n\n        // Inner loop - 6 iterations for fractal detail\n        for(int j = 1; j <= 6; j++) {\n            f = float(j*2);\n            p += sin(round(p.yxz * PI2) / PI * f + t * 0.5 + bass_att/16) / f;\n        }\n    }\n\n    // Apply final transformation\n    o = tanh(o / 1000.0);\n\n    // Output final color\n    ret = o.rgb;\n}\n","comp_hlsl":"shader_body\n{\n//MilkDrop3 Flip Mode:\n//uv = 1-uv;\n\n ret = GetPixel(uv);\n}"}