{"version":2,"baseVals":{"rating":3,"wave_r":0,"wave_g":0,"wave_b":0,"wave_x":0,"wave_y":0,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    // sample previous frame\n    ret = texture( sampler_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret *= 0.98; //or try: ret -= 0.004;\n}","comp":"// BigWings + IkeC - Heartfelt / https://www.shadertoy.com/view/ltffzl\n// Transpiled to HLSL using Milkwave\n\n#define tx sin(time)*0.5+1 // 0.5 <= tx <= 1.5\n\n// CONV: setting iChannel samplers to default noise texture\n#define iChannel0 sampler_stoy_london\n//#define iChannel0 sampler_grace\nsampler iChannel0;\n\n// CONV: adding helper functions\nfloat mod_conv(float x, float y) { return x - y * floor(x / y); }\nvec2 mod_conv(vec2 x, vec2 y) { return x - y * floor(x / y); }\nvec3 mod_conv(vec3 x, vec3 y) { return x - y * floor(x / y); }\nvec4 mod_conv(vec4 x, vec4 y) { return x - y * floor(x / y); }\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define HAS_HEART\n#define USE_POST_PROCESSING\n\n#define stime 70\n//#define stime 110\n#define stimetotal 1.2*stime\n\n\nvec3 N13(float p) {\n vec3 p3 = fract(vec3(p,p,p) * vec3(.1031,.11369,.13787));\n p3 += dot(p3, p3.yzx + 19.19);\n return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 N14(float t) {\n return fract(sin(t*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n return fract(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n return S(0., b, t)*S(1., b, t);\n}\n\nvec2 DropLayer2(vec2 uv_conv,  float t) {\n vec2 UV = uv_conv;\n\n uv_conv.y += t*0.75;\n vec2 a = vec2(6., 1.);\n vec2 grid = a*2.;\n vec2 id = floor(uv_conv*grid);\n\n float colShift = N(id.x);\n uv_conv.y += colShift;\n\n id = floor(uv_conv*grid);\n vec3 n = N13(id.x*35.2+id.y*2376.1);\n vec2 st = fract(uv_conv*grid)-vec2(.5, 0);\n\n float x = n.x-.5;\n\n float y = UV.y*20.;\n float wiggle = sin(y+sin(y));\n x += wiggle*(.5-abs(x))*(n.z-.5);\n x *= .7;\n float ti = fract(t+n.z);\n y = (Saw(.85, ti)-.5)*.9+.5;\n vec2 p = vec2(x, y);\n\n float d = length((st-p)*a.yx);\n\n float mainDrop = S(.4, .0, d);\n\n float r = sqrt(S(1., y, st.y));\n float cd = abs(st.x-x);\n float trail = S(.23*r, .15*r*r, cd);\n float trailFront = S(-.02, .02, st.y-y);\n trail *= trailFront*r*r;\n\n y = UV.y;\n float trail2 = S(.2*r, .0, cd);\n float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n y = fract(y*10.)+(st.y-.5);\n float dd = length(st-vec2(x, y));\n droplets = S(.3, 0., dd);\n float m = mainDrop+droplets*r*trailFront;\n\n return vec2(m, trail);\n}\n\nfloat StaticDrops(vec2 uv_conv,  float t) {\n uv_conv *= 40.;\n\n vec2 id = floor(uv_conv);\n uv_conv = fract(uv_conv)-.5;\n vec3 n = N13(id.x*107.45+id.y*3543.654);\n vec2 p = (n.xy-.5)*.7;\n float d = length(uv_conv-p);\n\n float fade = Saw(.025, fract(t+n.z));\n float c = S(.3, 0., d)*fract(n.z*10.)*fade;\n return c;\n}\n\nvec2 Drops(vec2 uv_conv,  float t, float l0, float l1, float l2) {\n float s = StaticDrops(uv_conv, t)*l0;\n vec2 m1 = DropLayer2(uv_conv, t)*l1;\n vec2 m2 = DropLayer2(uv_conv*1.85, t)*l2;\n\n float c = s+m1.x+m2.x;\n c = S(.3, 1., c);\n\n return vec2(c, max(m1.y*l0, m2.y*l1));\n}\n\nshader_body {\n vec4 fragColor = 0;\n // CONV: Center on screen, then try some aspect correction\n uv = (uv*2) - 1;\n uv *= aspect.xy;\n // CONV: Adjust this to flip the output (±uv.x, ±uv.y)\n uv = vec2(uv.x, -uv.y);\n\n vec2 fragCoord  = uv;\n //uv = (fragCoord.xy-.5*uv.xy) / uv.y;\n \n vec2 UV = fragCoord.xy/uv.xy;\n // vec2 UV = uv;\n\n // CONV: iMouse unsupported\n // vec3 M = iMouse.xyz/uv.xyz;\n //vec3 M = tx;\n float f = 0.3;\n\n // drop flow speed?\n vec3 M = 5;\n // float T = time+M.x*2.;\n float T;  \n \n #ifdef HAS_HEART\n  //T = mod_conv(time, 102.);\n  //T = mix(T, M.x*102., M.z>0.?1.:0.);\n  //T = mix(T, M.x*102., 0);\n  //T = fmod(time, stime);\n  T=fmod(time, stimetotal);\n #endif\n\n float t = T*.2;\n\n // CONV: iMouse unsupported\n //vec3 iMouse = vec3(sin(time), sin(time), 1);\n //vec3 iMouse = tx;\n vec3 iMouse = 1;\n\n float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    \n //float rainAmount = 1;\n\n float maxBlur = mix(3., 6., rainAmount);\n float minBlur = 2.;\n     \n float story = 0.;\n float heart = 0.;\n    \n #ifdef HAS_HEART\n  story = S(0, 0, T*2);\n\n  t = time;\n    \n  // float zoom= mix(.3, 1.2, story); // slowly zoom out\n  float zoom= mix(.4, 1.1, story); // slowly zoom out\n  //uv = uv*zoom*0.2;\n\n  uv = uv*zoom*0.9;\n\n  minBlur = 4.+S(.5, 1., story)*3.; // more opaque glass towards the end  \n  maxBlur = 6.+S(.5, 1., story)*1.5+bass_att/3;\n  \n  rainAmount = 1; // the rain is where the heart is  \n  maxBlur-= 1; // inside the heart slighly less foggy\n    \n  vec2 uvtx=uv*0.2;\n  uv *= 1.5; // zoom out a bit more\n  t *= .25;\n #else\n  float zoom = -cos(T*.2);\n  uv *= .7+zoom*.3;\n #endif\n\n UV = (UV-.5)*(.9+zoom*.1)+.5;\n\n float staticDrops = S(-.5, 1., rainAmount)*1.5;\n float layer1 = S(.25, .75, rainAmount); \n float layer2 = S(.0, .5, rainAmount);    \n    \n vec2 c = Drops(uv, t, staticDrops, layer1, layer2);\n \n #ifdef CHEAP_NORMALS\n  vec2 n = vec2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))\n #else\n  vec2 e = vec2(.001, 0.);\n  float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n  float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n  vec2 n = vec2(cx-c.x, cy-c.x); // expensive normals\n #endif\n    \n float focus = mix(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n // vec3 col = textureLod(iChannel0, UV+n, focus).rgb;\n // vec3 col = iChannel0.SampleLevel(sampler0, UV + n, focus).rgb;\n // vec3 col = tex2Dlod(iChannel0, vec4(uv+n, 0, focus)).rgb;\n // vec3 col = tex2Dlod(iChannel0, vec4(uv+n, 0, focus)).rgb;\n\n // focus=1; n=0;\n //float fac = 2.5;\n float facx = 2.5+bass_att;\n float facy = 2;\n vec2 flippedUV = vec2(uvtx.x*facx+0.5, 0.5-uvtx.y*facy);\n //vec2 flippedUV = vec2(UV.x+0.5, 0.5-UV.y);\n\n vec3 col = tex2Dlod(iChannel0, vec4(flippedUV+n, 0, focus)).rgb;\n    \n //col = vec3(heart,heart,heart);\n fragColor = vec4(col, 1);\n ret = fragColor;\n//MilkDrop3 Invert Mode:\nret = 1 - ret;\n}","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret *= 0.98; //or try: ret -= 0.004;\n}","comp_hlsl":"// BigWings + IkeC - Heartfelt / https://www.shadertoy.com/view/ltffzl\n// Transpiled to HLSL using Milkwave\n\n#define tx sin(time)*0.5+1 // 0.5 <= tx <= 1.5\n\n// CONV: setting iChannel samplers to default noise texture\n#define iChannel0 sampler_stoy_london\n//#define iChannel0 sampler_grace\nsampler iChannel0;\n\n// CONV: adding helper functions\nfloat mod_conv(float x, float y) { return x - y * floor(x / y); }\nfloat2 mod_conv(float2 x, float2 y) { return x - y * floor(x / y); }\nfloat3 mod_conv(float3 x, float3 y) { return x - y * floor(x / y); }\nfloat4 mod_conv(float4 x, float4 y) { return x - y * floor(x / y); }\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define HAS_HEART\n#define USE_POST_PROCESSING\n\n#define stime 70\n//#define stime 110\n#define stimetotal 1.2*stime\n\n\nfloat3 N13(float p) {\n float3 p3 = frac(float3(p,p,p) * float3(.1031,.11369,.13787));\n p3 += dot(p3, p3.yzx + 19.19);\n return frac(float3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat4 N14(float t) {\n return frac(sin(t*float4(123., 1024., 1456., 264.))*float4(6547., 345., 8799., 1564.));\n}\n\nfloat N(float t) {\n return frac(sin(t*12345.564)*7658.76);\n}\n\nfloat Saw(float b, float t) {\n return S(0., b, t)*S(1., b, t);\n}\n\nfloat2 DropLayer2(float2 uv_conv,  float t) {\n float2 UV = uv_conv;\n\n uv_conv.y += t*0.75;\n float2 a = float2(6., 1.);\n float2 grid = a*2.;\n float2 id = floor(uv_conv*grid);\n\n float colShift = N(id.x);\n uv_conv.y += colShift;\n\n id = floor(uv_conv*grid);\n float3 n = N13(id.x*35.2+id.y*2376.1);\n float2 st = frac(uv_conv*grid)-float2(.5, 0);\n\n float x = n.x-.5;\n\n float y = UV.y*20.;\n float wiggle = sin(y+sin(y));\n x += wiggle*(.5-abs(x))*(n.z-.5);\n x *= .7;\n float ti = frac(t+n.z);\n y = (Saw(.85, ti)-.5)*.9+.5;\n float2 p = float2(x, y);\n\n float d = length((st-p)*a.yx);\n\n float mainDrop = S(.4, .0, d);\n\n float r = sqrt(S(1., y, st.y));\n float cd = abs(st.x-x);\n float trail = S(.23*r, .15*r*r, cd);\n float trailFront = S(-.02, .02, st.y-y);\n trail *= trailFront*r*r;\n\n y = UV.y;\n float trail2 = S(.2*r, .0, cd);\n float droplets = max(0., (sin(y*(1.-y)*120.)-st.y))*trail2*trailFront*n.z;\n y = frac(y*10.)+(st.y-.5);\n float dd = length(st-float2(x, y));\n droplets = S(.3, 0., dd);\n float m = mainDrop+droplets*r*trailFront;\n\n return float2(m, trail);\n}\n\nfloat StaticDrops(float2 uv_conv,  float t) {\n uv_conv *= 40.;\n\n float2 id = floor(uv_conv);\n uv_conv = frac(uv_conv)-.5;\n float3 n = N13(id.x*107.45+id.y*3543.654);\n float2 p = (n.xy-.5)*.7;\n float d = length(uv_conv-p);\n\n float fade = Saw(.025, frac(t+n.z));\n float c = S(.3, 0., d)*frac(n.z*10.)*fade;\n return c;\n}\n\nfloat2 Drops(float2 uv_conv,  float t, float l0, float l1, float l2) {\n float s = StaticDrops(uv_conv, t)*l0;\n float2 m1 = DropLayer2(uv_conv, t)*l1;\n float2 m2 = DropLayer2(uv_conv*1.85, t)*l2;\n\n float c = s+m1.x+m2.x;\n c = S(.3, 1., c);\n\n return float2(c, max(m1.y*l0, m2.y*l1));\n}\n\nshader_body {\n float4 fragColor = 0;\n // CONV: Center on screen, then try some aspect correction\n uv = (uv*2) - 1;\n uv *= aspect.xy;\n // CONV: Adjust this to flip the output (±uv.x, ±uv.y)\n uv = float2(uv.x, -uv.y);\n\n float2 fragCoord  = uv;\n //uv = (fragCoord.xy-.5*uv.xy) / uv.y;\n \n float2 UV = fragCoord.xy/uv.xy;\n // float2 UV = uv;\n\n // CONV: iMouse unsupported\n // float3 M = iMouse.xyz/uv.xyz;\n //float3 M = tx;\n float f = 0.3;\n\n // drop flow speed?\n float3 M = 5;\n // float T = time+M.x*2.;\n float T;  \n \n #ifdef HAS_HEART\n  //T = mod_conv(time, 102.);\n  //T = lerp(T, M.x*102., M.z>0.?1.:0.);\n  //T = lerp(T, M.x*102., 0);\n  //T = fmod(time, stime);\n  T=fmod(time, stimetotal);\n #endif\n\n float t = T*.2;\n\n // CONV: iMouse unsupported\n //float3 iMouse = float3(sin(time), sin(time), 1);\n //float3 iMouse = tx;\n float3 iMouse = 1;\n\n float rainAmount = iMouse.z>0. ? M.y : sin(T*.05)*.3+.7;\n    \n //float rainAmount = 1;\n\n float maxBlur = lerp(3., 6., rainAmount);\n float minBlur = 2.;\n     \n float story = 0.;\n float heart = 0.;\n    \n #ifdef HAS_HEART\n  story = S(0, 0, T*2);\n\n  t = time;\n    \n  // float zoom= lerp(.3, 1.2, story); // slowly zoom out\n  float zoom= lerp(.4, 1.1, story); // slowly zoom out\n  //uv = uv*zoom*0.2;\n\n  uv = uv*zoom*0.9;\n\n  minBlur = 4.+S(.5, 1., story)*3.; // more opaque glass towards the end  \n  maxBlur = 6.+S(.5, 1., story)*1.5+bass_att/3;\n  \n  rainAmount = 1; // the rain is where the heart is  \n  maxBlur-= 1; // inside the heart slighly less foggy\n    \n  float2 uvtx=uv*0.2;\n  uv *= 1.5; // zoom out a bit more\n  t *= .25;\n #else\n  float zoom = -cos(T*.2);\n  uv *= .7+zoom*.3;\n #endif\n\n UV = (UV-.5)*(.9+zoom*.1)+.5;\n\n float staticDrops = S(-.5, 1., rainAmount)*1.5;\n float layer1 = S(.25, .75, rainAmount); \n float layer2 = S(.0, .5, rainAmount);    \n    \n float2 c = Drops(uv, t, staticDrops, layer1, layer2);\n \n #ifdef CHEAP_NORMALS\n  float2 n = float2(dFdx(c.x), dFdy(c.x));// cheap normals (3x cheaper, but 2 times shittier ;))\n #else\n  float2 e = float2(.001, 0.);\n  float cx = Drops(uv+e, t, staticDrops, layer1, layer2).x;\n  float cy = Drops(uv+e.yx, t, staticDrops, layer1, layer2).x;\n  float2 n = float2(cx-c.x, cy-c.x); // expensive normals\n #endif\n    \n float focus = lerp(maxBlur-c.y, minBlur, S(.1, .2, c.x));\n // float3 col = textureLod(iChannel0, UV+n, focus).rgb;\n // float3 col = iChannel0.SampleLevel(sampler0, UV + n, focus).rgb;\n // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;\n // float3 col = tex2Dlod(iChannel0, float4(uv+n, 0, focus)).rgb;\n\n // focus=1; n=0;\n //float fac = 2.5;\n float facx = 2.5+bass_att;\n float facy = 2;\n float2 flippedUV = float2(uvtx.x*facx+0.5, 0.5-uvtx.y*facy);\n //float2 flippedUV = float2(UV.x+0.5, 0.5-UV.y);\n\n float3 col = tex2Dlod(iChannel0, float4(flippedUV+n, 0, focus)).rgb;\n    \n //col = float3(heart,heart,heart);\n fragColor = float4(col, 1);\n ret = fragColor;\n//MilkDrop3 Invert Mode:\nret = 1 - ret;\n}"}