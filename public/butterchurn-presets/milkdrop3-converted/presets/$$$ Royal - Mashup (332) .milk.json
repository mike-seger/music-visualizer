{"version":2,"baseVals":{"rating":2,"gammaadj":1,"wave_mode":7,"additivewave":1,"wave_thick":1,"modwavealphabyvolume":1,"wave_brighten":0,"wave_a":0.001,"wave_scale":0.958,"wave_smoothing":0.45,"modwavealphastart":0,"modwavealphaend":1.32,"warpanimspeed":30.965,"warpscale":2.572,"zoom":1.00901,"warp":0.00054,"wave_r":0,"wave_g":0,"wave_b":0,"mv_x":25.6,"mv_y":9.6,"mv_l":0,"mv_r":0.5,"mv_g":0.5,"mv_b":0.5,"mv_a":0},"shapes":[{"baseVals":{"textured":1,"x":0.09,"y":0.9,"rad":0.22437,"tex_zoom":1.76002,"r2":1,"g2":0,"a2":0.6,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":100,"additive":1,"x":0.26,"y":0.2,"rad":0.39317,"tex_zoom":6.19589,"r":0,"g":0.55,"b":0.5,"g2":0.4,"b2":0.4,"a2":0.07,"border_r":0.3,"border_g":0.7,"border_b":0.8,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":44,"additive":1,"x":0.503,"rad":0.03886,"tex_zoom":0.60986,"g":0.1,"a":0.9,"r2":1,"b2":1,"border_r":0.5,"border_g":0.5,"border_b":0.5,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":100,"rad":0.01,"tex_zoom":0.49981,"r":0,"g2":0,"border_r":0.2,"border_g":0.7,"border_b":0.5,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"samples":282,"sep":20,"usedots":1,"thick":1,"additive":1,"scaling":3.91581,"smoothing":0.1,"r":0.2,"g":0.3,"a":0.6,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"usedots":1,"thick":1,"scaling":0.89152,"smoothing":0.82,"a":0.1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"thick":1,"scaling":0.89152,"smoothing":0.82,"r":0,"g":0.2,"b":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"spectrum":1,"usedots":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['dx_residual'] = 0; a['dy_residual'] = 0; a['bass_thresh'] = 0; a['rg'] = 0; a['q9'] = 0;}());","frame_eqs_str":"(function(){a['wave_r']=(0.85+(0.25*Math.sin(((0.437*a['time'])+1)))); a['wave_g']=(0.85+(0.25*Math.sin(((0.544*a['time'])+2)))); a['wave_b']=(0.85+(0.25*Math.sin(((0.751*a['time'])+3)))); a['rot']=(a['rot']+(0.010*((0.60*Math.sin((0.381*a['time'])))+(0.40*Math.sin((0.579*a['time'])))))); a['cx']=(a['cx']+(0.210*((0.60*Math.sin((0.374*a['time'])))+(0.40*Math.sin((0.294*a['time'])))))); a['cy']=(a['cy']+(0.210*((0.60*Math.sin((0.393*a['time'])))+(0.40*Math.sin((0.223*a['time'])))))); a['dx']=(a['dx']+(0.003*((0.60*Math.sin((0.234*a['time'])))+(0.40*Math.sin((0.277*a['time'])))))); a['dy']=(a['dy']+(0.003*((0.60*Math.sin((0.284*a['time'])))+(0.40*Math.sin((0.247*a['time'])))))); a['decay']=(a['decay']-(0.01*equal(mod(a['frame'],6), 0))); a['dx']=(a['dx']+a['dx_residual']); a['dy']=(a['dy']+a['dy_residual']); a['bass_thresh']=((above(a['bass_att'], a['bass_thresh'])*2)+((1-above(a['bass_att'], a['bass_thresh']))*(((a['bass_thresh']-1.3)*0.96)+1.3))); a['dx_residual']=(((equal(a['bass_thresh'], 2.13)*0.016)*Math.sin((a['time']*7)))+((1-equal(a['bass_thresh'], 2.13))*a['dx_residual'])); a['dy_residual']=(((equal(a['bass_thresh'], 2.13)*0.012)*Math.sin((a['time']*9)))+((1-equal(a['bass_thresh'], 2.13))*a['dy_residual'])); a['wave_x']=(a['wave_x']-(a['dx_residual']*7)); a['wave_y']=(a['wave_y']-(a['dy_residual']*7)); a['wave_mystery']=(a['time']*0.03); a['rg']=Math.max((a['rg']*0.77), (0.02+(0.5*Math.min(2, (Math.max(0, (a['mid_att']-1))*1.3))))); a['q9']=a['rg']; a['zoom']=(a['zoom']+(a['q9']*0.1));}());","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"wave_r = 0.85 + 0.25*sin(0.437*time+1);\nwave_g = 0.85 + 0.25*sin(0.544*time+2);\nwave_b = 0.85 + 0.25*sin(0.751*time+3);\nrot = rot + 0.010*( 0.60*sin(0.381*time) + 0.40*sin(0.579*time) );\ncx = cx + 0.210*( 0.60*sin(0.374*time) + 0.40*sin(0.294*time) );\ncy = cy + 0.210*( 0.60*sin(0.393*time) + 0.40*sin(0.223*time) );\ndx = dx + 0.003*( 0.60*sin(0.234*time) + 0.40*sin(0.277*time) );\ndy = dy + 0.003*( 0.60*sin(0.284*time) + 0.40*sin(0.247*time) );\ndecay = decay - 0.01*equal(frame%6,0);\ndx = dx + dx_residual;\ndy = dy + dy_residual;\nbass_thresh = above(bass_att,bass_thresh)*2 + (1-above(bass_att,bass_thresh))*((bass_thresh-1.3)*0.96+1.3);\ndx_residual = equal(bass_thresh,2.13)*0.016*sin(time*7) + (1-equal(bass_thresh,2.13))*dx_residual;\ndy_residual = equal(bass_thresh,2.13)*0.012*sin(time*9) + (1-equal(bass_thresh,2.13))*dy_residual;\nwave_x = wave_x - dx_residual*7;\nwave_y = wave_y - dy_residual*7;\nwave_mystery = time*0.03;\n\n//zoom = zoom + 0.005*( 0.60*sin(0.1934*time+3) + 0.40*sin(0.307*time+9) );\n//zoom = zoom + max(0,bass_att-1.1)*0.2;\n//warp = warp + max(0,treb_att-1.1)*1.0;\n\n// this is a great way to respond to beats:\n// once you get one, let it decay at a constant rate!!\nrg = max(rg*0.77, 0.02 + 0.5*min(2,max(0,mid_att-1)*1.3));\nq9 = rg;\n\nzoom = zoom + q9*0.1;","pixel_eqs_eel":"","warp":"shader_body\n{\n    // sample previous frame\n    ret = texture( sampler_main, uv ).xyz;\n\nvec4 noise9 = texture(sampler_noisevol_hq, \n                      ((uv.xyy*q27\n                       )*texsize.xyy*texsize_noisevol_hq.zww\n                      ).xyz*\n                      vec3(1,1,0)*0.05 + \n                      time*vec3(0,0,1)*q29\n                     ).xyz;\nif(ret.x> q21*q13         && ret.x<= q24*q11        )ret.y -= (noise9).x*.5; \nif(ret.y> q22*q11         && ret.y<= q25*q12        )ret.z -= (noise9).y*.5; \nif(ret.z> q23*q12         && ret.z<= q26*q13        )ret.x -= (noise9).z*.5; \n    // take the difference between the crisp and blurred images,\n    // then add it back into the image.  Creates spots and stripes over time.\n    ret += (ret - ((texture(sampler_blur2, uv).xyz * scale2) + bias2))*0.3;\n    ret *= 0.9;\n\n    // add noise:\n    vec2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n    ret += (texture(sampler_noise_lq, dither_uv).xyz-0.5)/256.0 * 112;\n\n    // desaturate over time, to keep the globs white\n    ret = mix(ret, lum(ret), 0.2);\n}","comp":"\nvec2 rs, rs0, uv2, uv3,uv4,dz;\nvec3 noise, ret1, neu;\nvec2 hor = vec2 (texsize.z,0);\nvec2 ver = vec2 (0, texsize.w);\n\nshader_body {\nvec2 uv1 = (uv-.5 )*aspect.xy;\n\nfloat z = .1/uv1.y/uv1.x;\n\nrs0.x = uv1.x*z;\nrs0.y = z;\nrs.x = rs0.x + time/2;\nrs.y = rs0.y + time/2;\n\nnoise = lum(texture(sampler_noise_hq,rs/2).xyz);\nnoise = noise-.55;\n\nvec3 mask = clamp(24*(uv1.y), 0.0, 1.0) ;\n\n\n\nfloat dist = 1;\nfloat inten = 1;\nret1 = 0;\nint anz = 4;\nint n = 1;\ndz = 0;\nwhile (n <= anz) {\n    dist = 1-fract(1.0/anz*n+time/18); //evtl sqrt !;\n\n    inten =  sqrt(dist)*(1-dist)*4;\n    uv = uv1*aspect.yx;\n    uv3 = uv*dist +.5 + vec2(0.02*((n%2)-.5),.05);\n\n    dz.x += inten*(2*lum(texture(sampler_main, uv3+hor).xyz)- 2*lum(texture(sampler_main, uv3-hor).xyz));\n    dz.y += inten*(2*lum(texture(sampler_main, uv3+ver).xyz)- 2*lum(texture(sampler_main, uv3-ver).xyz));\n    neu = texture(sampler_main, uv3).xyz;\n    ret1 = max(ret1,neu*inten);\nn++;\n}\n\ndz = (dz*(.5+rand_preset.z));\nvec2 pos = 2*(rand_preset.xy-.5);\nuv1 = 4*uv1;\nvec2 uv_rr = sin(uv1 + dz + pos);\nvec2 uv_gg = sin(uv1 + dz*1.4 + pos);\nvec2 uv_bb = sin(uv1 + dz*1.8 +pos);\nvec3 size = vec3 (.01,.01,.01) * (1+rand_preset.xyz/2)*(.5+rand_preset.y);\nvec3 mus = vec3(1/length(uv_rr),1/length(uv_gg),1/length(uv_bb))*size;\n\nret = mus*((rand_preset.x-.5)*4*ret1+8*(1+rand_preset))\n-  ret1.r *.5 + (ret1.g + ret1.b)/3 ;\nret-=slow_roam_sin.wzy*roam_cos.zxy*.4;\nret *= 1+ret;\n//ret = texture(sampler_main, uv_orig+.5).xyz;\n}","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_main, uv ).xyz;\n\nfloat4 noise9 = tex3D(sampler_noisevol_hq, \n                      ((uv.xyy*q27\n                       )*texsize.xyy*texsize_noisevol_hq.zww\n                      ).xyz*\n                      float3(1,1,0)*0.05 + \n                      time*float3(0,0,1)*q29\n                     );\nif(ret.x> q21*q13         && ret.x<= q24*q11        )ret.y -= (noise9).x*.5; \nif(ret.y> q22*q11         && ret.y<= q25*q12        )ret.z -= (noise9).y*.5; \nif(ret.z> q23*q12         && ret.z<= q26*q13        )ret.x -= (noise9).z*.5; \n    // take the difference between the crisp and blurred images,\n    // then add it back into the image.  Creates spots and stripes over time.\n    ret += (ret - GetBlur2(uv))*0.3;\n    ret *= 0.9;\n\n    // add noise:\n    float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n    ret += (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)/256.0 * 112;\n\n    // desaturate over time, to keep the globs white\n    ret = lerp(ret, lum(ret), 0.2);\n}","comp_hlsl":"\nfloat2 rs, rs0, uv2, uv3,uv4,dz;\nfloat3 noise, ret1, neu;\nstatic float2 hor = float2 (texsize.z,0);\nstatic float2 ver = float2 (0, texsize.w);\n\nshader_body {\nfloat2 uv1 = (uv-.5 )*aspect.xy;\n\nfloat z = .1/uv1.y/uv1.x;\n\nrs0.x = uv1.x*z;\nrs0.y = z;\nrs.x = rs0.x + time/2;\nrs.y = rs0.y + time/2;\n\nnoise = lum(tex2D(sampler_noise_hq,rs/2));\nnoise = noise-.55;\n\nfloat3 mask = saturate(24*(uv1.y)) ;\n\n\n\nfloat dist = 1;\nfloat inten = 1;\nret1 = 0;\nint anz = 4;\nint n = 1;\ndz = 0;\nwhile (n <= anz) {\n    dist = 1-frac(1.0/anz*n+time/18); //evtl sqrt !;\n\n    inten =  sqrt(dist)*(1-dist)*4;\n    uv = uv1*aspect.yx;\n    uv3 = uv*dist +.5 + float2(0.02*((n%2)-.5),.05);\n\n    dz.x += inten*(2*lum(GetPixel(uv3+hor))- 2*lum(GetPixel(uv3-hor)));\n    dz.y += inten*(2*lum(GetPixel(uv3+ver))- 2*lum(GetPixel(uv3-ver)));\n    neu = GetPixel(uv3);\n    ret1 = max(ret1,neu*inten);\nn++;\n}\n\ndz = (dz*(.5+rand_preset.z));\nfloat2 pos = 2*(rand_preset.xy-.5);\nuv1 = 4*uv1;\nfloat2 uv_rr = sin(uv1 + dz + pos);\nfloat2 uv_gg = sin(uv1 + dz*1.4 + pos);\nfloat2 uv_bb = sin(uv1 + dz*1.8 +pos);\nfloat3 size = float3 (.01,.01,.01) * (1+rand_preset.xyz/2)*(.5+rand_preset.y);\nfloat3 mus = float3(1/length(uv_rr),1/length(uv_gg),1/length(uv_bb))*size;\n\nret = mus*((rand_preset.x-.5)*4*ret1+8*(1+rand_preset))\n-  ret1.r *.5 + (ret1.g + ret1.b)/3 ;\nret-=slow_roam_sin.wzy*roam_cos.zxy*.4;\nret *= 1+ret;\n//ret = GetPixel(uv_orig+.5);\n}"}