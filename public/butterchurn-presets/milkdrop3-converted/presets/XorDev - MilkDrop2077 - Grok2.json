{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":7,"additivewave":1,"wave_thick":1,"wave_brighten":0,"brighten":1,"darken":1,"wave_a":3.2,"wave_scale":1.768,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpscale":1.331,"fshader":1,"zoom":0.99951,"warp":0.01,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":1.248,"mv_l":5,"mv_b":0,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"sides":20,"additive":1,"thickoutline":1,"num_inst":444,"x":0.8,"rad":0.12821,"tex_zoom":5.42791,"r":0,"b":1,"a":0.2,"g2":0,"b2":0.5,"border_a":0},"init_eqs_str":"(function(){a['i'] = 0; a['k1'] = 0; a['zmax'] = 0; a['speed'] = 0; a['z'] = 0; a['out'] = 0; a['i']=0; for(var mdparser_idx358=0;mdparser_idx358<1024;mdparser_idx358++){a['z']=(rand(1)+0.1); a['megabuf'][Math.floor((a['i']+2))]=a['z']; a['megabuf'][Math.floor(a['i'])]=div((rand(1)-0.5),a['z']); a['megabuf'][Math.floor((a['i']+1))]=div((rand(1)-0.5),a['z']); a['i']+=3;}}())","frame_eqs_str":"(function(){a['i']=a['instance']; a['k1']=div(a['i'],a['num_inst']); a['zmax']=7; a['speed']=0.15; a['z']=a['megabuf'][Math.floor(((3*a['i'])+2))]; a['x']=(div(a['megabuf'][Math.floor((3*a['i']))],a['z'])+0.5); a['y']=((div(a['megabuf'][Math.floor(((3*a['i'])+1))],a['z'])*a['reg32'])+0.5); a['rad']=(div(0.022,(a['z']*a['zmax']))*a['reg32']); a['out']=((((((((((a['x']>1)?1:0)||((a['x']<0)?1:0))?1:0)||((a['y']>1)?1:0))?1:0)||((a['y']<0)?1:0))?1:0)||((a['z']<0)?1:0))?1:0); ((Math.abs(a['out'])>0.00001)?((function(){a['megabuf'][Math.floor((3*a['i']))]=(rand(2)-1); a['megabuf'][Math.floor(((3*a['i'])+1))]=(rand(2)-1); return a['megabuf'][Math.floor(((3*a['i'])+2))]=1;})()):(a['megabuf'][Math.floor(((a['i']*3)+2))]-=div(a['speed'],a['fps']))); a['a']=(1-pow(a['z'], 4)); a['a']*=0.6;}())","init_eqs_eel":"i=0;\nloop (1024,\n  z=rand(1)+.1;\n  megabuf(i+2) = z;\n  megabuf(i)  = (rand(1)-0.5)/z;\n  megabuf(i+1)= (rand(1)-.5)/z;\ni+=3;);","frame_eqs_eel":"i=instance;\nk1 = i/num_inst;\nzmax = 7;\nspeed=.15;\n\nz=megabuf(3*i+2);\nx = megabuf(3*i)/z+.5;\ny = megabuf(3*i+1)/z*reg32+0.5;\n\nrad = .022/(z*zmax)*reg32 ;\n\nout=(x>1)||(x<0)||(y>1)||(y<0)||(z<0);\nif (out,\n  megabuf(3*i)= (rand(2)-1); //x\n  megabuf(3*i+1)=(rand(2)-1); //y\n  megabuf(3*i+2)=1;\n,\n  megabuf(i*3+2)-=speed/fps;\n);\n\na=1-pow(z,4);\na*=0.6;"},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"usedots":1,"thick":1},"init_eqs_str":"(function(){a['s'] = 0; a['xp'] = 0; a['yp'] = 0; a['zp'] = 0; a['t1'] = 0; a['x_screen'] = 0; a['y_screen'] = 0; a['advance'] = 0; }())","frame_eqs_str":"(function(){a['advance']=(a['advance']+0.005); a['advance']=((Math.abs(above(a['advance'], 2))>0.00001)?(0):(a['advance'])); a['t1']=a['advance'];}())","point_eqs_str":"(function(){a['s']=(a['sample']*6.28); a['xp']=(((Math.sin(a['s'])+Math.sin((a['s']*0.14)))+Math.sin((a['s']*32.3)))+Math.sin((a['s']*9.8))); a['xp']=(a['xp']*0.20); a['yp']=(((Math.cos(a['s'])+Math.sin((a['s']*0.24)))+Math.cos((a['s']*17.4)))+Math.sin((a['s']*37.7))); a['yp']=(a['yp']*0.20); a['zp']=(((Math.cos(a['s'])+Math.cos((a['s']*5.24)))+Math.cos((a['s']*47.4)))+Math.cos((a['s']*27.7))); a['zp']=(a['zp']*0.25); a['zp']=((a['zp']+1)-a['t1']); a['zp']=((Math.abs(below(a['zp'], 0))>0.00001)?((a['zp']+2)):(a['zp'])); a['a']=(1-(a['zp']*0.5)); a['zp']=(a['zp']*0.7); a['x_screen']=(div(a['xp'],a['zp'])+0.5); a['y_screen']=(div(a['yp'],a['zp'])+0.5); a['x']=a['x_screen']; a['y']=a['y_screen']; a['r']=1; a['g']=1; a['b']=1;}())","init_eqs_eel":"","frame_eqs_eel":"advance=advance+ 0.005;\nadvance=if( above(advance,2) , 0, advance);\nt1=advance","point_eqs_eel":"s=sample*6.28;\n\n//plot random x position via function of sample pos;\nxp=sin(s)+sin(s*0.14)+sin(s*32.3)+sin(s*9.8);\nxp=xp*0.20;\n\n//plot random y position via function of sample pos;\nyp=cos(s)+sin(s*0.24)+cos(s*17.4)+sin(s*37.7);\nyp=yp*0.20;\n\n//plot random z position via function of sample pos;\nzp=cos(s)+cos(s*5.24)+cos(s*47.4)+cos(s*27.7);\nzp=zp*0.25;\n\n//pull stars toward screen\nzp=zp + 1 - t1;\n\n//correct when below 0\nzp=if( below(zp,0) , zp+2 , zp );\n\n//darken far stars\na=(1 - zp*0.5);\n\nzp=zp*0.7;\n\nx_screen=xp/zp + 0.5;\ny_screen=yp/zp + 0.5;\n\nx=x_screen;\ny=y_screen;\n\nr=1;\ng=1;\nb=1;"},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n  \n    // Calculate aspect ratio correction\n    float aspect = aspect.x / aspect.y;\n    vec2 aspect_scale = vec2(aspect, 1.0);\n    \n    // Center and scale UVs\n    vec2 uv_centered = (uv - 0.5) * 1.8;\n    vec2 p = uv_centered * aspect_scale;\n    \n    // Add rotation (time-based)\n    float angle = time * 0.05; // Rotation speed (0.5 radians per second)\n    float sin_rot = sin(angle);\n    float cos_rot = cos(angle);\n    p = vec2(\n        p.x * cos_rot - p.y * sin_rot,\n        p.x * sin_rot + p.y * cos_rot\n    );\n    \n    // Distance function with rotation\n    float d = length(p) - 0.5 + 0.01 / (p.x + p.y);\n    \n    // Glow effect\n    float o = 0.1 / abs(d);\n    \n    // Output\n    ret = vec3(o, o, o);\n}","comp":"shader_body\n{\n    ret = texture(sampler_main, uv).xyz;\n    ret *= 1.28; //gamma\n    ret *= hue_shader; //old hue shader effect\n    ret *= ret; //darken\n}","warp_hlsl":"shader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n  \n    // Calculate aspect ratio correction\n    float aspect = aspect.x / aspect.y;\n    float2 aspect_scale = float2(aspect, 1.0);\n    \n    // Center and scale UVs\n    float2 uv_centered = (uv - 0.5) * 1.8;\n    float2 p = uv_centered * aspect_scale;\n    \n    // Add rotation (time-based)\n    float angle = time * 0.05; // Rotation speed (0.5 radians per second)\n    float sin_rot = sin(angle);\n    float cos_rot = cos(angle);\n    p = float2(\n        p.x * cos_rot - p.y * sin_rot,\n        p.x * sin_rot + p.y * cos_rot\n    );\n    \n    // Distance function with rotation\n    float d = length(p) - 0.5 + 0.01 / (p.x + p.y);\n    \n    // Glow effect\n    float o = 0.1 / abs(d);\n    \n    // Output\n    ret = float3(o, o, o);\n}","comp_hlsl":"shader_body\n{\n    ret = tex2D(sampler_main, uv).xyz;\n    ret *= 1.28; //gamma\n    ret *= hue_shader; //old hue shader effect\n    ret *= ret; //darken\n}"}