{"version":2,"baseVals":{"rating":5,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":15,"additivewave":1,"wave_thick":1,"wrap":0,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":0.625,"wave_smoothing":0.9,"modwavealphastart":0.88,"modwavealphaend":1.98,"warpanimspeed":0.01,"warpscale":0.01,"fshader":1,"warp":0.01,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0.005,"ob_r":0.47,"ob_g":0.31,"ob_b":0.38,"ib_r":0,"ib_g":0,"ib_b":0,"mv_x":64,"mv_y":48,"mv_l":1,"mv_r":1.06,"mv_b":0.819,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['speed'] = 0; a['speedinv'] = 0; a['q1'] = 0; a['qa'] = 0; a['q2'] = 0; a['qb'] = 0; a['q3'] = 0; a['qc'] = 0; a['nut']=0; a['wvr']=0; a['decay']=0; a['dcsp']=0;}());","frame_eqs_str":"(function(){a['decay']=0.99; a['zoom']=1.000; a['speed']=0.920; a['speedinv']=(1-a['speed']); a['q1']=((a['qa']*a['speed'])+(a['bass']*a['speedinv'])); a['q2']=((a['qb']*a['speed'])+(a['mid']*a['speedinv'])); a['q3']=((a['qc']*a['speed'])+(a['treb']*a['speedinv'])); a['qa']=a['q1']; a['qb']=a['q2']; a['qc']=a['q3'];}());","pixel_eqs_str":"","init_eqs_eel":"nut=0;\n\n\nwvr=0;\ndecay=0;\ndcsp=0","frame_eqs_eel":"decay=0.99;\nzoom=1.000;\nspeed=0.920;\nspeedinv=1-speed;\nq1=(qa*speed + bass*speedinv);\nq2=(qb*speed + mid *speedinv);\nq3=(qc*speed + treb*speedinv);\nqa=q1;\nqb=q2;\nqc=q3","pixel_eqs_eel":"","warp":"shader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n\n    // Get screen coordinates\n    vec2 fragCoord = uv * texsize;\n    vec2 r = texsize;\n    vec3 FC = vec3(fragCoord, 0.7);\n\n    float t = time;\n\n    // Initialize output\n    vec4 o = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Main shader logic\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    float i = 0.0;\n    float z = 0.0;\n    float f = 0.0;\n\n    // Outer loop - 50 iterations\n    for(int iter = 0; iter < 50; iter++) {\n        i += bass_att;\n\n        // Update z and calculate distance field\n        f = 0.0052 + 0.08 * abs(length(p) - 5.7);\n        z += f;\n\n        // Add to output color (RGB channels only)\n        o.rgb += (p / z + q2) / f;\n\n        // Update ray position\n        p = z * (FC.rgb * 2.0 - vec3(r.x, r.y, r.y)) / r.y;\n        p.z += 9.0;\n\n        // Inner loop - 7 iterations for fractal detail\n        for(int j = 1; j <= 7; j++) {\n            f = float(j);\n            p += sin(round(p.zxy / 0.02) * 0.02 * f - t) / f;\n        }\n    }\n\n    // Apply final transformation\n    o = tanh(o / 2420);\n\n    // Output final color\n    ret = o.rgb;\n}\n","comp":"uniform sampler2D sampler_devboxb;\nuniform sampler2D sampler_suff5;\nshader_body\n{//MilkDrop3 Flip Mode:\nuv = 1-uv;\n\nfloat t = time; // set velocity here\nvec2 c = (uv-0.5)*aspect.wz;\nfloat ang_hq = atan(c.x,c.y);\nvec2 spiral = vec2(ang_hq*q11*4+t,aspect.w*log(length(c))+ang_hq*q11-t);\n//spiral = 0.5 + (0.5 - abs( fract( spiral * 0.5 ) * 2.0 - 1.0 ))*0.83; // mirror\nspiral = 0.5 - (0.5 - fract(spiral))*0.866; // mirror\nuv = 0.5 + (uv-0.5)*0.88;\n    ret = texture(sampler_main, uv).xyz;\n    ret *= 1.00; //gamma\n ret = mix(texture(sampler_main, uv).xyz.y*vec3(0.6,0,0),mix(1,vec3(1,0,0),((texture(sampler_blur1, uv).xyz * scale1) + bias1).y),texture(sampler_main, uv).xyz.x*0.6);\n// ret = mix(ret,vec3(1,0,0),texture(sampler_main, spiral).xyz.y*bass*0.5);\n// ret = mix(ret,1,texture(sampler_main, spiral).xyz.x*treb*0.25);\n//MilkDrop3 Solarize Mode:\nret = ret*(1-ret)*4;\n//MilkDrop3 Invert Mode:\nret = 1 - ret;\n}","warp_hlsl":"shader_body\n{\n    //Shader By XorDev (x.com/XorDev), ported to MilkDrop by MilkDrop2077\n\n    // Get screen coordinates\n    float2 fragCoord = uv * texsize;\n    float2 r = texsize;\n    float3 FC = float3(fragCoord, 0.7);\n\n    float t = time;\n\n    // Initialize output\n    float4 o = float4(0.0, 0.0, 0.0, 0.0);\n\n    // Main shader logic\n    float3 p = float3(0.0, 0.0, 0.0);\n    float i = 0.0;\n    float z = 0.0;\n    float f = 0.0;\n\n    // Outer loop - 50 iterations\n    for(int iter = 0; iter < 50; iter++) {\n        i += bass_att;\n\n        // Update z and calculate distance field\n        f = 0.0052 + 0.08 * abs(length(p) - 5.7);\n        z += f;\n\n        // Add to output color (RGB channels only)\n        o.rgb += (p / z + q2) / f;\n\n        // Update ray position\n        p = z * (FC.rgb * 2.0 - float3(r.x, r.y, r.y)) / r.y;\n        p.z += 9.0;\n\n        // Inner loop - 7 iterations for fractal detail\n        for(int j = 1; j <= 7; j++) {\n            f = float(j);\n            p += sin(round(p.zxy / 0.02) * 0.02 * f - t) / f;\n        }\n    }\n\n    // Apply final transformation\n    o = tanh(o / 2420);\n\n    // Output final color\n    ret = o.rgb;\n}\n","comp_hlsl":"sampler sampler_devboxb;\nsampler sampler_suff5;\nshader_body\n{//MilkDrop3 Flip Mode:\nuv = 1-uv;\n\nfloat t = time; // set velocity here\nfloat2 c = (uv-0.5)*aspect.wz;\nfloat1 ang_hq = atan2(c.x,c.y);\nfloat2 spiral = float2(ang_hq*q11*4+t,aspect.w*log(length(c))+ang_hq*q11-t);\n//spiral = 0.5 + (0.5 - abs( frac( spiral * 0.5 ) * 2.0 - 1.0 ))*0.83; // mirror\nspiral = 0.5 - (0.5 - frac(spiral))*0.866; // mirror\nuv = 0.5 + (uv-0.5)*0.88;\n    ret = tex2D(sampler_main, uv).xyz;\n    ret *= 1.00; //gamma\n ret = lerp(GetPixel(uv).y*float3(0.6,0,0),lerp(1,float3(1,0,0),GetBlur1(uv).y),GetPixel(uv).x*0.6);\n// ret = lerp(ret,float3(1,0,0),GetPixel(spiral).y*bass*0.5);\n// ret = lerp(ret,1,GetPixel(spiral).x*treb*0.25);\n//MilkDrop3 Solarize Mode:\nret = ret*(1-ret)*4;\n//MilkDrop3 Invert Mode:\nret = 1 - ret;\n}"}