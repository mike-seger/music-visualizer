{"version":2,"baseVals":{"rating":5,"gammaadj":1.28,"decay":0.8,"echo_zoom":1,"echo_orient":3,"wave_mode":7,"additivewave":1,"modwavealphabyvolume":1,"wave_brighten":0,"brighten":1,"wave_a":0.001,"wave_scale":1.286,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"zoomexp":3.04777,"zoom":1.0173,"warp":0.01605,"wave_g":0.65,"wave_b":0.65,"ob_size":0,"ob_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['z'] = 0; a['d_x'] = 0; a['q25'] = 0; a['index'] = 0; a['q29'] = 0; a['q1'] = 0; a['dec_med'] = 0; a['is_beat'] = 0; a['q31'] = 0; a['q23'] = 0; a['q24'] = 0; a['dec_slow'] = 0; a['q26'] = 0; a['avg'] = 0; a['r'] = 0; a['beat'] = 0; a['d_y'] = 0; a['peak'] = 0; a['q27'] = 0; a['t0'] = 0; a['q32'] = 0; a['q28'] = 0; a['q30'] = 0;}());","frame_eqs_str":"(function(){a['dec_med']=pow(0.9, div(30,a['fps'])); a['dec_slow']=pow(0.99, div(30,a['fps'])); a['beat']=Math.max(Math.max(a['bass'], a['mid']), a['treb']); a['avg']=((a['avg']*a['dec_slow'])+(a['beat']*(1-a['dec_slow']))); a['is_beat']=(above(a['beat'], ((0.5+a['avg'])+a['peak']))*above(a['time'], (a['t0']+0.2))); a['t0']=((a['is_beat']*a['time'])+((1-a['is_beat'])*a['t0'])); a['peak']=((a['is_beat']*a['beat'])+(((1-a['is_beat'])*a['peak'])*a['dec_med'])); a['index']=mod((a['index']+a['is_beat']),2); a['d_x']=((Math.abs(a['is_beat'])>0.00001)?(((rand(2000)-1000)*0.001)):(a['d_x'])); a['d_y']=((Math.abs(a['is_beat'])>0.00001)?(((rand(2000)-1000)*0.001)):(a['d_y'])); a['r']=((Math.abs(a['is_beat'])>0.00001)?(((rand(2000)-1000)*0.001)):(a['r'])); a['z']=((Math.abs(a['is_beat'])>0.00001)?((rand(1000)*0.001)):(a['z'])); a['zoom']=(1.03+(a['z']*0.06)); a['rot']=(a['r']*0.06); a['dx']=(a['d_x']*0.01); a['dy']=(a['d_y']*0.01); a['q1']=1; a['q23']=div(rand(1000),1000); a['q24']=div(rand(1000),1000); a['q25']=(div(rand(1000),1000)*6.28); a['q26']=(a['q25']-3.14); a['q27']=(div(rand(1000),12000)+0.04); a['q28']=div(rand(1000),1000); a['q29']=div(rand(1000),1000); a['q30']=(div(rand(1000),1000)*6.28); a['q31']=(a['q30']-3.14); a['q32']=(div(rand(1000),14000)+0.04);}());","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"dec_med = pow (0.9, 30/fps);\ndec_slow = pow (0.99, 30/fps);\nbeat = max (max (bass, mid), treb); \navg = avg*dec_slow + beat*(1-dec_slow);\nis_beat = above(beat, .5+avg+peak) * above (time, t0+.2);\nt0 = is_beat*time + (1-is_beat)*t0;\npeak = is_beat * beat + (1-is_beat)*peak*dec_med;\nindex = (index + is_beat) %2;\n\n\nd_x = if(is_beat, (rand(2000)-1000)*0.001 , d_x);\nd_y = if(is_beat, (rand(2000)-1000)*0.001 , d_y);\nr = if(is_beat, (rand(2000)-1000)*0.001 , r);\nz = if(is_beat, rand(1000)*0.001 , z);\nzoom = 1.03 + z*0.06;\nrot = r*0.06;\ndx = d_x*0.01;\ndy = d_y*0.01;\nq1 = 1;\n\nq23 = rand(1000)/1000;\nq24 = rand(1000)/1000;\nq25 = (rand(1000)/1000)*6.28;\nq26 = q25 - 3.14;\nq27 = (rand(1000)/12000)+0.04;\n\nq28 = rand(1000)/1000;\nq29 = rand(1000)/1000;\nq30 = (rand(1000)/1000)*6.28;\nq31 = q30 - 3.14;\nq32 = (rand(1000)/14000)+0.04;","pixel_eqs_eel":"","warp":"vec2 complex_mul(vec2 factorA, vec2 factorB){\n   return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 complex_pow(vec2 base, int exponent){\n   vec2 exponentiation = vec2(1,0);\n   for(int i = 0; i<exponent; i++){\n      exponentiation = complex_mul(base,exponentiation);\n   }\n   return exponentiation;\n}\n\nvec2 complex_square(vec2 domain){\n   return complex_mul(domain,domain);\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n   return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                  numerator.y*denominator.x - numerator.x*denominator.y)/\n          (denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 uv_aspect(vec2 uvo, vec2 uvm, vec2 aspectr, vec2 motion_scale){\n   return 0.5 + (mix(uvo,uvm,motion_scale)-0.5)*aspectr;\n}\n\nvec2 uv_scale(vec2 domain, vec2 center, vec2 scale){\n   return center + (domain-center)*scale;\n}\n\nvec2 uv_torus_mirror(vec2 domain, float cutoff){\n   return 0.5 + (1.0 - abs( fract( domain * 0.5 ) * 2 - 1.0 )-0.5)*cutoff;\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan(c.x,c.y);\n   return vec2(ang_hq*M_INV_PI_2, rad_hq);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, int fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center);\n   return vec2(polar.x*fins+coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_moebius_transformation(vec2 domain, vec2 zeroPoint, vec2 infinityPoint,float zoom){\n   return complex_div((domain - zeroPoint)*zoom, domain - infinityPoint)+0.5;\n}\n\nbool mask_rectangle(vec2 domain, vec2 position, vec2 dimensions){\n   return (domain.x>position.x-dimensions.x)*(domain.x<position.x+dimensions.x)*\n          (domain.y>position.y-dimensions.y)*(domain.y<position.y+dimensions.y);\n}\n\nbool mask_circle(vec2 domain, vec2 position, float radius){\n   return length(domain-position)<radius;\n}\n\nbool mask_spiral_logarithmic(vec2 domain, vec2 center, int fins, float thickness, float spiral_factor, float zoom){\n   vec2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan(c.x,c.y);\n\n   return fract(fins*ang_hq*M_INV_PI_2 + spiral_factor*log(1/rad_hq)+zoom)<thickness;\n}\n\nfloat figure_spiral(vec2 domain, vec2 center, int fins, float thickness, float spiral_factor, float zoom){\n   vec2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan(c.x,c.y);\n\n   return fract(fins*ang_hq*M_INV_PI_2 + spiral_factor*log(1/rad_hq)+zoom)<thickness;\n}\n\nfloat figure_circle(vec2 domain, vec2 position, float radius){\n   return clamp(1-length(domain-position)/radius, 0.0, 1.0);\n}\n\nfloat figure_border(vec2 domain, float thickness){\n   vec2 help_uv = fract(domain-0.5);\n   help_uv = min(help_uv,1-help_uv)*2;\n   return clamp(max(help_uv.x,help_uv.y)-1+thickness, 0.0, 1.0)/(thickness);\n}\n\nshader_body\n{\nvec2 base_uv = uv_aspect(uv_orig, uv, aspect.wz, 0);\nvec2 zeroPoint = vec2(0.25,0.5);\nvec2 infinityPoint = vec2(0.75,0.5);\nfloat zoom = 0.5;\nvec2 moebius_uv = uv_moebius_transformation(base_uv, zeroPoint, infinityPoint, zoom );\n//moebius_uv = uv_torus_mirror(moebius_uv,1);\nret = figure_border(moebius_uv,0.2);\nret = mix(ret,1,figure_circle(moebius_uv,0.5,0.2));\nret = mask_spiral_logarithmic(moebius_uv,0.5,1,0.5,1,time);\n//ret = mix(ret,vec3(1,0,0),mask_circle(base_uv,zeroPoint,0.01));\n//ret = mix(ret,vec3(0,0,1),mask_circle(base_uv,infinityPoint,0.01));\n}","comp":"shader_body\n{\nret = texture(sampler_main, uv).xyz;\n}","warp_hlsl":"float2 complex_mul(float2 factorA, float2 factorB){\n   return float2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nfloat2 complex_pow(float2 base, int exponent){\n   float2 exponentiation = float2(1,0);\n   for(int i = 0; i<exponent; i++){\n      exponentiation = complex_mul(base,exponentiation);\n   }\n   return exponentiation;\n}\n\nfloat2 complex_square(float2 domain){\n   return complex_mul(domain,domain);\n}\n\nfloat2 complex_div(float2 numerator, float2 denominator){\n   return float2( numerator.x*denominator.x + numerator.y*denominator.y,\n                  numerator.y*denominator.x - numerator.x*denominator.y)/\n          (denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat2 uv_aspect(float2 uvo, float2 uvm, float2 aspectr, float2 motion_scale){\n   return 0.5 + (lerp(uvo,uvm,motion_scale)-0.5)*aspectr;\n}\n\nfloat2 uv_scale(float2 domain, float2 center, float2 scale){\n   return center + (domain-center)*scale;\n}\n\nfloat2 uv_torus_mirror(float2 domain, float cutoff){\n   return 0.5 + (1.0 - abs( frac( domain * 0.5 ) * 2 - 1.0 )-0.5)*cutoff;\n}\n\nfloat2 uv_polar(float2 domain, float2 center){\n   float2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan2(c.x,c.y);\n   return float2(ang_hq*M_INV_PI_2, rad_hq);\n}\n\nfloat2 uv_polar_logarithmic(float2 domain, float2 center, int fins, float log_factor, float2 coord){\n   float2 polar = uv_polar(domain, center);\n   return float2(polar.x*fins+coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nfloat2 uv_moebius_transformation(float2 domain, float2 zeroPoint, float2 infinityPoint,float zoom){\n   return complex_div((domain - zeroPoint)*zoom, domain - infinityPoint)+0.5;\n}\n\nbool mask_rectangle(float2 domain, float2 position, float2 dimensions){\n   return (domain.x>position.x-dimensions.x)*(domain.x<position.x+dimensions.x)*\n          (domain.y>position.y-dimensions.y)*(domain.y<position.y+dimensions.y);\n}\n\nbool mask_circle(float2 domain, float2 position, float radius){\n   return length(domain-position)<radius;\n}\n\nbool mask_spiral_logarithmic(float2 domain, float2 center, int fins, float thickness, float spiral_factor, float zoom){\n   float2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan2(c.x,c.y);\n\n   return frac(fins*ang_hq*M_INV_PI_2 + spiral_factor*log(1/rad_hq)+zoom)<thickness;\n}\n\nfloat figure_spiral(float2 domain, float2 center, int fins, float thickness, float spiral_factor, float zoom){\n   float2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan2(c.x,c.y);\n\n   return frac(fins*ang_hq*M_INV_PI_2 + spiral_factor*log(1/rad_hq)+zoom)<thickness;\n}\n\nfloat figure_circle(float2 domain, float2 position, float radius){\n   return saturate(1-length(domain-position)/radius);\n}\n\nfloat figure_border(float2 domain, float thickness){\n   float2 help_uv = frac(domain-0.5);\n   help_uv = min(help_uv,1-help_uv)*2;\n   return saturate(max(help_uv.x,help_uv.y)-1+thickness)/(thickness);\n}\n\nshader_body\n{\nfloat2 base_uv = uv_aspect(uv_orig, uv, aspect.wz, 0);\nfloat2 zeroPoint = float2(0.25,0.5);\nfloat2 infinityPoint = float2(0.75,0.5);\nfloat zoom = 0.5;\nfloat2 moebius_uv = uv_moebius_transformation(base_uv, zeroPoint, infinityPoint, zoom );\n//moebius_uv = uv_torus_mirror(moebius_uv,1);\nret = figure_border(moebius_uv,0.2);\nret = lerp(ret,1,figure_circle(moebius_uv,0.5,0.2));\nret = mask_spiral_logarithmic(moebius_uv,0.5,1,0.5,1,time);\n//ret = lerp(ret,float3(1,0,0),mask_circle(base_uv,zeroPoint,0.01));\n//ret = lerp(ret,float3(0,0,1),mask_circle(base_uv,infinityPoint,0.01));\n}","comp_hlsl":"shader_body\n{\nret = GetPixel(uv);\n}"}