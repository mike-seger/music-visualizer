{"version":2,"baseVals":{"rating":4,"gammaadj":1.46,"decay":0.935,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":2,"wave_mode":5,"wave_thick":1,"brighten":1,"darken":1,"wave_a":0.001,"wave_scale":2.385,"wave_smoothing":0.9,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpscale":1.331,"fshader":1,"zoom":0.9995,"warp":0.009,"wave_r":0.1,"wave_g":0.3,"wave_b":0.5,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":0,"mv_y":0,"mv_l":1,"mv_g":0.91,"mv_b":0.71,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.02;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const vec2 p = uv * PI2 - 250.0;\n    vec2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const vec2 i_plus_t = i + t;\n        const vec2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x);\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const vec2 pd = vec2(p.x/denom, p.y/denom2);\n        c += inversesqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - pow(c, 1.4);\n    const vec3 colour = pow(abs(c), 8.0);\n    ret = vec4(colour, 1.0);\n}","comp":"\nshader_body {\n\n    //Don't drink and drive, take LSD and teleport\n    ret = texture(sampler_main, uv).xyz;\n    \n    // Time-varying color using cosine waves\n    vec3 col = 0.8 + 0.5 * cos(time/15 + vec3(uv.x, uv.y, uv.x) + vec3(0, 2, 4));\n    \n    // Output final color mixing with the old frame\n    ret = ret * 1.5 * vec4(col, 1.0);\n\n}","warp_hlsl":"shader_body\n{\n    #define PI2 6.28318530718\n    #define MAX_ITER 5\n    #define INV_MAX_ITER 0.2  // 1.0/MAX_ITER\n    \n    const float time2 = time * 0.02;\n    uv = uv_orig;\n    \n    // Pattern coordinates - optimized to remove fmod when not needed\n    const float2 p = uv * PI2 - 250.0;\n    float2 i = p;\n    float c = 1.0;\n    const float brightness = 0.005;\n    const float invBrightness = 200.0;  // 1.0/brightness\n    \n    // Precompute time components\n    const float t0 = time2;\n    const float t1 = time2 + time;\n    \n    // Fractal iteration loop - unrolled and optimized\n    for (int n = 0; n < MAX_ITER; n++) {\n        const float t = t0 * (1.0 - (3.5 / (float(n)+1.0)));\n        const float sin_t = sin(t);\n        const float cos_t = cos(t);\n        \n        // Update i with optimized trig operations\n        const float2 i_plus_t = i + t;\n        const float2 i_minus_t = i - t;\n        \n        i.x = p.x + cos_t*cos(i_minus_t.x) - sin_t*sin(i_minus_t.x) \n                   + sin_t*cos(i_plus_t.y) + cos_t*sin(i_plus_t.y);\n        i.y = p.y + sin_t*cos(i_minus_t.y) - cos_t*sin(i_minus_t.y) \n                   + cos_t*cos(i_plus_t.x) - sin_t*sin(i_plus_t.x);\n        \n        // Optimized denominator calculations\n        const float sin_ixt = sin(i.x + t);\n        const float cos_iyt = cos(i.y + t);\n        const float denom = sin_ixt * invBrightness;\n        const float denom2 = cos_iyt * invBrightness;\n        \n        // Optimized length calculation\n        const float2 pd = float2(p.x/denom, p.y/denom2);\n        c += rsqrt(dot(pd, pd));  // Faster than 1.0/length()\n    }\n    \n    // Post-processing\n    c *= INV_MAX_ITER;  // Faster than division\n    c = 1.17 - pow(c, 1.4);\n    const float3 colour = pow(abs(c), 8.0);\n    ret = float4(colour, 1.0);\n}","comp_hlsl":"\nshader_body {\n\n    //Don't drink and drive, take LSD and teleport\n    ret = tex2D(sampler_main, uv).xyz;\n    \n    // Time-varying color using cosine waves\n    float3 col = 0.8 + 0.5 * cos(time/15 + float3(uv.x, uv.y, uv.x) + float3(0, 2, 4));\n    \n    // Output final color mixing with the old frame\n    ret = ret * 1.5 * float4(col, 1.0);\n\n}"}