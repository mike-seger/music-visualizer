{"version":2,"baseVals":{"rating":4,"gammaadj":2.7,"wave_mode":6,"additivewave":1,"wave_dots":1,"wave_brighten":0,"wrap":0,"wave_a":0.004,"wave_scale":0.653,"wave_smoothing":0.9,"modwavealphastart":0.5,"modwavealphaend":1,"warpscale":1.331,"zoom":0.99951,"warp":0.01,"wave_b":0.1,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":25.6,"mv_y":14.4,"mv_l":1,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"shader_body\n{\nvec2 uv_m = 1.0 - abs( fract( uv * 0.5 ) * 2.0 - 1.0 ); // Eo.S' mirror code\nret.x = texture( sampler_fc_main, uv_m ).z; // first julia fractal iteration\nret.y = mix(mix(texture( sampler_fc_main, uv_m ).x, ret.x,0.5), \n             texture(sampler_main, uv_orig).xyz.y,\n             0.75); // 75% of motion blur to the green channel\n\n\nvec2 d = texsize.zw*6;\nvec2 uv_z = (uv_orig-0.5)*0.998 + 0.5; // a small dose of zoom-in\nvec3 dx = ( ((texture(sampler_blur1, uv_z + vec2(1,0)*d).xyz * scale1) + bias1) - ((texture(sampler_blur1, uv_z-vec2(1,0)*d).xyz * scale1) + bias1) );\nvec3 dy = ( ((texture(sampler_blur1, uv_z + vec2(0,1)*d).xyz * scale1) + bias1) - ((texture(sampler_blur1, uv_z-vec2(0,1)*d).xyz * scale1) + bias1) );\nuv_z -=vec2(dx.z,dy.z)*texsize.zw*2; //shortening of the nebulous matter\nret.z = max((tex2d(sampler_fc_main,uv_m).x-0.5)*3*clamp(1-length(uv_orig-0.5)*3.2, 0.0, 1.0), // feeded by the inner of the red channel\n             tex2d(sampler_fc_main,uv_z).z);\nret.z += (tex2d(sampler_fc_main,uv_z).z - ((texture(sampler_blur1, clamp(uv_z, 0.0, 1.0)).xyz * scale1) + bias1).z)*0.02; // sort of geiss' skin dot code\n}","comp":"float z;\nvec3 ret1, neu, mus;\nvec2 rs,rs2,uv1,uv2, uv3,uv4,uv6,dz,dz1;\nshader_body\n{\nvec2 uv2;\n//uv = (uv-0.5) * aspect.xy;    \ndz = 0;\n\nvec2 hor = vec2(texsize.z,0);\nvec2 ver = vec2(0,texsize.w);\n\nfloat dist = 1;\nfloat inten = 1;\nret1 = 0;\nint anz = 3;\nint n = 0;\nuv4 = (uv+.01);\n    dz.x = lum(texture(sampler_main, uv4+hor).xyz- texture(sampler_main, uv4-hor).xyz);\n    dz.y = lum(texture(sampler_main, uv4+ver).xyz- texture(sampler_main, uv4-ver).xyz);\n\nmus = texture(sampler_main, uv+.0*dz).xyz+.0;\n\nuv2 = uv-.5;\ndz = 0;\nwhile (n <= anz) {\n    dist = 1-fract(1.0/anz*n+time/2); //evtl sqrt !;\n\n    inten =  sqrt(dist)*(1-dist)*2;\n    uv3 = 2*uv2*dist +.5;\n//    uv3 *= aspect.yx;\n    uv3 = fract (uv3);\n    neu = texture(sampler_main, uv3).xyz+((texture(sampler_blur1, uv3).xyz * scale1) + bias1);\n    ret1 = max(ret1,neu*inten);\nn++;\n}\n\n\nret = ret1.bgr*(.5+mus)  +  3*mus*(.1+ret1);\n//ret = texture(sampler_main, uv_orig).xyz*2;\n}","warp_hlsl":"shader_body\n{\nfloat2 uv_m = 1.0 - abs( frac( uv * 0.5 ) * 2.0 - 1.0 ); // Eo.S' mirror code\nret.x = tex2D( sampler_fc_main, uv_m ).z; // first julia fractal iteration\nret.y = lerp(lerp(tex2D( sampler_fc_main, uv_m ).x, ret.x,0.5), \n             GetPixel(uv_orig).y,\n             0.75); // 75% of motion blur to the green channel\n\n\nfloat2 d = texsize.zw*6;\nfloat2 uv_z = (uv_orig-0.5)*0.998 + 0.5; // a small dose of zoom-in\nfloat3 dx = ( GetBlur1(uv_z + float2(1,0)*d) - GetBlur1(uv_z-float2(1,0)*d) );\nfloat3 dy = ( GetBlur1(uv_z + float2(0,1)*d) - GetBlur1(uv_z-float2(0,1)*d) );\nuv_z -=float2(dx.z,dy.z)*texsize.zw*2; //shortening of the nebulous matter\nret.z = max((tex2d(sampler_fc_main,uv_m).x-0.5)*3*saturate(1-length(uv_orig-0.5)*3.2), // feeded by the inner of the red channel\n             tex2d(sampler_fc_main,uv_z).z);\nret.z += (tex2d(sampler_fc_main,uv_z).z - GetBlur1(saturate(uv_z)).z)*0.02; // sort of geiss' skin dot code\n}","comp_hlsl":"float z;\nfloat3 ret1, neu, mus;\nfloat2 rs,rs2,uv1,uv2, uv3,uv4,uv6,dz,dz1;\nshader_body\n{\nfloat2 uv2;\n//uv = (uv-0.5) * aspect.xy;    \ndz = 0;\n\nfloat2 hor = float2(texsize.z,0);\nfloat2 ver = float2(0,texsize.w);\n\nfloat dist = 1;\nfloat inten = 1;\nret1 = 0;\nint anz = 3;\nint n = 0;\nuv4 = (uv+.01);\n    dz.x = lum(GetPixel(uv4+hor)- GetPixel (uv4-hor));\n    dz.y = lum(GetPixel(uv4+ver)- GetPixel (uv4-ver));\n\nmus = GetPixel(uv+.0*dz)+.0;\n\nuv2 = uv-.5;\ndz = 0;\nwhile (n <= anz) {\n    dist = 1-frac(1.0/anz*n+time/2); //evtl sqrt !;\n\n    inten =  sqrt(dist)*(1-dist)*2;\n    uv3 = 2*uv2*dist +.5;\n//    uv3 *= aspect.yx;\n    uv3 = frac (uv3);\n    neu = GetPixel(uv3)+GetBlur1(uv3);\n    ret1 = max(ret1,neu*inten);\nn++;\n}\n\n\nret = ret1.bgr*(.5+mus)  +  3*mus*(.1+ret1);\n//ret = GetPixel(uv_orig)*2;\n}"}