{"version":2,"baseVals":{"rating":1,"gammaadj":1.9,"echo_zoom":1.169,"additivewave":1,"wave_thick":1,"modwavealphabyvolume":1,"wrap":0,"wave_a":0.001,"wave_scale":0.133,"wave_smoothing":0,"wave_mystery":-0.87,"modwavealphastart":1,"modwavealphaend":1.482,"warp":0.01,"wave_r":0.395,"wave_g":0.5,"wave_b":0.55,"wave_y":0.38,"ob_size":0.005,"ob_a":1,"ib_size":0,"mv_x":14.28,"mv_a":0},"shapes":[{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":" ","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"smoothing":0.46,"g":0.97,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"g":1.06,"b":1.11,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"scaling":0.8,"a":1.21,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"smoothing":0.6,"b":1.08,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"(function(){a['bt'] = 0; a['q1'] = 0; a['tt'] = 0; a['q2'] = 0; a['mt'] = 0; a['q3'] = 0; a['q5'] = 0; a['q6'] = 0;}());","frame_eqs_str":"(function(){a['warp']=0; a['wave_a']=0; a['zoom']=1.0; a['decay']=0.5; a['bt']=(a['bt']+div(a['bass'],a['fps'])); a['q1']=a['bt']; a['tt']=(a['tt']+div(a['treb'],a['fps'])); a['q2']=(a['tt']+(0.22*a['time'])); a['mt']=(a['mt']+div(a['mid'],a['fps'])); a['q3']=(a['mt']+(0.24*a['time'])); a['q5']=a['aspectx']; a['q6']=a['aspecty'];}());","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"warp=0;\nwave_a=0;\nzoom=1.0;\ndecay=0.5;\n\n\nbt=bt+bass/fps;\nq1=bt;\ntt=tt+treb/fps;\nq2=tt+.22*time;\nmt=mt+mid/fps;\nq3=mt+.24*time;\n\n\n\nq5=aspectx;\nq6=aspecty;","pixel_eqs_eel":"","warp":"#define tex sampler_MilkDrop3_020\nsampler tex;\n\nshader_body\n{\n\nvec2 xy1=0;\nvec2 xymod=uv-.5;\n\nxy1.x=sin(time/6)*xymod.x-0.5-cos(time/6)*xymod.y;\nxy1.y=cos(time/6)*xymod.x-0.5+sin(time/6)*xymod.y;\n\nuv=xy1*aspect.xy;\n\nret = texture(tex, uv ).xyz;\n\n}","comp":"uniform sampler2D sampler_pw_noise_lq;\n\nvec2 rs, rss, rss0, tmp, uvo;\nvec3 noise;\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n   return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                  numerator.y*denominator.x - numerator.x*denominator.y)/\n          (denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan(c.x,c.y);\n   return vec2(ang_hq, rad_hq);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, int fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center);\n   return vec2(polar.x*fins+coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_moebius_transformation(vec2 domain, vec2 zeroPoint, vec2 infinityPoint,float zoom){\n   return complex_div((domain - zeroPoint)*zoom, domain - infinityPoint)+0.5;\n}\n\nvec2 uv_bipolar_logarithmic(vec2 domain, vec2 northPole, vec2 southPole, int fins, float log_factor, vec2 coord){\n   vec2 help_uv = uv_moebius_transformation(domain, northPole, southPole, 1);\n   return uv_polar_logarithmic(help_uv,0.5,fins,log_factor,coord)*vec2(M_INV_PI_2,1);\n}\n\nvec2 uv_scale(vec2 domain, vec2 center, vec2 scale){\n   return center + (domain-center)*scale;\n}\nvec2 uv_lens_half_sphere(vec2 domain, vec2 position, float radius, float refractivity){\n   vec2 polar = uv_polar(domain, position);\n   float cone = clamp(1-polar.y/radius, 0.0, 1.0);\n   float halfsphere = sqrt(1-pow(cone-1,2));\n   float w = atan(1-cone,halfsphere);\n   float refrac_w = w-asin(sin(w)/refractivity);\n   float refrac_d = 1-cone - sin(refrac_w)*halfsphere/cos(refrac_w);\n   vec2 refrac_uv =position+vec2(sin(polar.x),cos(polar.x))*refrac_d*radius;\n   bool mask =(length(domain-position)<radius);\n   return !mask*domain + \n           mask*refrac_uv;\n}\n\n\nfloat hardcore_stars(vec2 domain, vec2 center, float o){\n\n   vec2 uv1 = domain-center;\n   rss0.x = atan(uv1.x, uv1.y)/2;\n   rss0.y = .013/(length (uv1));\n   rss = vec2 (rss0.x+q1/3,rss0.y+time+o);\n   rss = (mat2(.7,.7,-.7,.7) * rss);\n   float noise = (texture(sampler_pw_noise_lq,rss/32).xyz-.5 >= 0);\n   tmp = abs(fract(rss*18)-.5);\n   vec3 dots = clamp(.04/length(tmp), 0.0, 1.0) *noise;\n   rss = vec2 (rss0.x,rss0.y+(time+o)/4);\n   rss = (mat2(.7,.7,-.7,.7) * rss);\n   noise = (texture(sampler_pw_noise_lq,rss/32).xyz-.5 >= 0);\n   tmp = abs(fract(rss*8)-.5);\n   dots += clamp(.02/length(tmp), 0.0, 1.0) * noise;\n   dots *= clamp(1.2/abs(rss0.y), 0.0, 1.0);\n   return dots*dots;\nreturn 0;\n}\n\n\n\n\n\n\nshader_body\n{\nuv = 0.5 + (uv-0.5)*aspect.wz;\ntime *= 0.4;\n\nvec2 pole1 =vec2(0.1,0.5);\nvec2 pole2 =vec2(0.9,0.5);\n\nfloat stars = hardcore_stars(uv,pole1,0) + hardcore_stars(uv,pole2,2);\n\nuv = uv_bipolar_logarithmic(uv, pole1, pole2, 2, 0.3, vec2(q26,q27)*vec2(8,1));\nuv = 0.5 + (1.0 - abs( fract( uv * 0.5 ) * 2 - 1.0 )-0.5)*0.98; // Eo.S. mirror code with cutted borders\nuv = uv.yx;\n\nvec2 uv1 = uv;\nvec2 d = texsize.zw*3;\nvec3 dx = ((texture(sampler_blur1, uv1 + vec2(1,0)*d).xyz * scale1) + bias1) - ((texture(sampler_blur1, uv1 - vec2(1,0)*d).xyz * scale1) + bias1);\nvec3 dy = ((texture(sampler_blur1, uv1 + vec2(0,1)*d).xyz * scale1) + bias1) - ((texture(sampler_blur1, uv1 - vec2(0,1)*d).xyz * scale1) + bias1);\nuv1 = uv+vec2(dx.x,dy.x)*texsize.zw*32;\n     ret = texture(sampler_main, uv1).xyz.x*vec3(1,0,0)*0.5;\n\nret.x += (+dx.x - dy.x)*0.4;\nret.x = pow(ret.x,0.8)*1.2;\n\nret = mix(ret,vec3(1,1,1),texture(sampler_main, uv1).xyz.z);\n\n//ret = mix(ret,1-texture(sampler_main, uv).xyz*1.5,stars);\nret*=1.2;\nret -= 0.1;\nret /= vec3(1.3,2.1,-1.2);\nret /= vec3(-1.2,0.7,-2.8);\n}","warp_hlsl":"#define tex sampler_MilkDrop3_020\nsampler tex;\n\nshader_body\n{\n\nfloat2 xy1=0;\nfloat2 xymod=uv-.5;\n\nxy1.x=sin(time/6)*xymod.x-0.5-cos(time/6)*xymod.y;\nxy1.y=cos(time/6)*xymod.x-0.5+sin(time/6)*xymod.y;\n\nuv=xy1*aspect.xy;\n\nret = tex2D(tex, uv ).xyz;\n\n}","comp_hlsl":"sampler sampler_pw_noise_lq;\n\nfloat2 rs, rss, rss0, tmp, uvo;\nfloat3 noise;\n\nfloat2 complex_div(float2 numerator, float2 denominator){\n   return float2( numerator.x*denominator.x + numerator.y*denominator.y,\n                  numerator.y*denominator.x - numerator.x*denominator.y)/\n          (denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat2 uv_polar(float2 domain, float2 center){\n   float2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan2(c.x,c.y);\n   return float2(ang_hq, rad_hq);\n}\n\nfloat2 uv_polar_logarithmic(float2 domain, float2 center, int fins, float log_factor, float2 coord){\n   float2 polar = uv_polar(domain, center);\n   return float2(polar.x*fins+coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nfloat2 uv_moebius_transformation(float2 domain, float2 zeroPoint, float2 infinityPoint,float zoom){\n   return complex_div((domain - zeroPoint)*zoom, domain - infinityPoint)+0.5;\n}\n\nfloat2 uv_bipolar_logarithmic(float2 domain, float2 northPole, float2 southPole, int fins, float log_factor, float2 coord){\n   float2 help_uv = uv_moebius_transformation(domain, northPole, southPole, 1);\n   return uv_polar_logarithmic(help_uv,0.5,fins,log_factor,coord)*float2(M_INV_PI_2,1);\n}\n\nfloat2 uv_scale(float2 domain, float2 center, float2 scale){\n   return center + (domain-center)*scale;\n}\nfloat2 uv_lens_half_sphere(float2 domain, float2 position, float radius, float refractivity){\n   float2 polar = uv_polar(domain, position);\n   float cone = saturate(1-polar.y/radius);\n   float halfsphere = sqrt(1-pow(cone-1,2));\n   float w = atan2(1-cone,halfsphere);\n   float refrac_w = w-asin(sin(w)/refractivity);\n   float refrac_d = 1-cone - sin(refrac_w)*halfsphere/cos(refrac_w);\n   float2 refrac_uv =position+float2(sin(polar.x),cos(polar.x))*refrac_d*radius;\n   bool mask =(length(domain-position)<radius);\n   return !mask*domain + \n           mask*refrac_uv;\n}\n\n/* code from Martins hardcore mix - Danke ;) */\nfloat hardcore_stars(float2 domain, float2 center, float o){\n\n   float2 uv1 = domain-center;\n   rss0.x = atan2(uv1.x, uv1.y)/2;\n   rss0.y = .013/(length (uv1));\n   rss = float2 (rss0.x+q1/3,rss0.y+time+o);\n   rss = mul(rss,float2x2(.7,.7,-.7,.7));\n   float noise = (tex2D(sampler_pw_noise_lq,rss/32)-.5 >= 0);\n   tmp = abs(frac(rss*18)-.5);\n   float3 dots = saturate(.04/length(tmp)) *noise;\n   rss = float2 (rss0.x,rss0.y+(time+o)/4);\n   rss = mul(rss,float2x2(.7,.7,-.7,.7));\n   noise = (tex2D(sampler_pw_noise_lq,rss/32)-.5 >= 0);\n   tmp = abs(frac(rss*8)-.5);\n   dots += saturate(.02/length(tmp)) * noise;\n   dots *= saturate(1.2/abs(rss0.y));\n   return dots*dots;\nreturn 0;\n}\n\n\n\n\n\n\nshader_body\n{\nuv = 0.5 + (uv-0.5)*aspect.wz;\ntime *= 0.4;\n\nfloat2 pole1 =float2(0.1,0.5);\nfloat2 pole2 =float2(0.9,0.5);\n\nfloat stars = hardcore_stars(uv,pole1,0) + hardcore_stars(uv,pole2,2);\n\nuv = uv_bipolar_logarithmic(uv, pole1, pole2, 2, 0.3, float2(q26,q27)*float2(8,1));\nuv = 0.5 + (1.0 - abs( frac( uv * 0.5 ) * 2 - 1.0 )-0.5)*0.98; // Eo.S. mirror code with cutted borders\nuv = uv.yx;\n\nfloat2 uv1 = uv;\nfloat2 d = texsize.zw*3;\nfloat3 dx = GetBlur1(uv1 + float2(1,0)*d) - GetBlur1(uv1 - float2(1,0)*d);\nfloat3 dy = GetBlur1(uv1 + float2(0,1)*d) - GetBlur1(uv1 - float2(0,1)*d);\nuv1 = uv+float2(dx.x,dy.x)*texsize.zw*32;\n     ret = GetPixel(uv1).x*float3(1,0,0)*0.5;\n\nret.x += (+dx.x - dy.x)*0.4;\nret.x = pow(ret.x,0.8)*1.2;\n\nret = lerp(ret,float3(1,1,1),GetPixel(uv1).z);\n\n//ret = lerp(ret,1-GetPixel(uv)*1.5,stars);\nret*=1.2;\nret -= 0.1;\nret /= float3(1.3,2.1,-1.2);\nret /= float3(-1.2,0.7,-2.8);\n}"}